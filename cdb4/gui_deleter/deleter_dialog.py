"""
/***************************************************************************
 Class CDB4DeleterDialog

        This is a QGIS plugin for the CityGML 3D City Database.
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                             -------------------
        begin                : 2023-01-20
        git sha              : $Format:%H$
        author(s)            : Giorgio Agugiaro
        email                : g.agugiaro@tudelft.nl                               
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""
import os
from psycopg2.extensions import connection as pyconn

from qgis.core import Qgis, QgsMessageLog, QgsRectangle, QgsGeometry, QgsWkbTypes, QgsCoordinateReferenceSystem
from qgis.gui import QgsRubberBand, QgsMapCanvas

from qgis.PyQt import uic, QtWidgets
from qgis.PyQt.QtCore import Qt
from qgis.PyQt.QtWidgets import QMessageBox

from ...cdb_tools_main import CDBToolsMain # Used only to add the type of the function parameters

from ..gui_db_connector.other_classes import Connection # Used only to add the type of the function parameters
from ..gui_db_connector.db_connector_dialog import DBConnectorDialog
from ..gui_geocoder.geocoder_dialog import GeoCoderDialog

from ..gui_db_connector.functions import conn_functions as conn_f
from ..shared.functions import sql as sh_sql
from ..shared.functions import general_functions as gen_f

from .functions import tab_conn_widget_functions as tc_wf
from .functions import tab_conn_functions as tc_f
from .functions import tab_settings_widget_functions as ts_wf
from .functions import canvas, sql
from .functions import threads as thr
from .other_classes import DeleterDialogChecks, DeleterDefaultSettings

from . import deleter_constants as c

# This loads the .ui file so that PyQt can populate the plugin with the elements from Qt Designer
FORM_CLASS, _ = uic.loadUiType(os.path.join(
    os.path.dirname(__file__), "ui", "cdb4_deleter_dialog.ui"))

class CDB4DeleterDialog(QtWidgets.QDialog, FORM_CLASS):
    """User Dialog class of the plugin.
    The GUI is imported from an external .ui xml
    """

    def __init__(self, cdbMain: CDBToolsMain, parent=None):
        """Constructor."""
        super(CDB4DeleterDialog, self).__init__(parent)
        # Set up the user interface from Designer through FORM_CLASS.
        # After self.setupUi() you can access any designer object by doing
        # self.<objectname>, and you can use autoconnect slots - see
        # http://qt-project.org/doc/qt-4.8/designer-using-a-ui-file.html#widgets-and-dialogs-with-auto-connect

        self.setupUi(self)

        ############################################################
        ## From here you can add your variables or constants
        ############################################################

        self.DIALOG_NAME: str = cdbMain.PLUGIN_NAME_DELETER

        # # Variable to store the previous connection of a database.
        self.prev_conn: pyconn = None
        # # Variable to store the previous connection parameters.
        self.prev_DB: Connection = None

        self.settings = DeleterDefaultSettings()
        self.checks = DeleterDialogChecks()

        # Variable to store metadata about the Feature Types (i.e. CityGML modules/packages) 
        self.RootClassFeaturesRegistry: dict = {}
        self.FeatureTypesRegistry: dict = {}

        # Variable to store the selected crs.
        self.CRS: QgsCoordinateReferenceSystem = cdbMain.iface.mapCanvas().mapSettings().destinationCrs()

        # Variable to store the selected extents.
        self.CURRENT_EXTENTS: QgsRectangle = cdbMain.iface.mapCanvas().extent()
        # Variable to store the extents of the selected cdb_schema
        self.CDB_SCHEMA_EXTENTS = QgsRectangle()
        # Variable to store the extents of the delete extents
        self.DELETE_EXTENTS = QgsRectangle()

        # Variable to store an additional canvas (to show the extents in the CONNECTION TAB).
        self.CANVAS_C: QgsMapCanvas = QgsMapCanvas()
        self.CANVAS_C.enableAntiAliasing(True)
        self.CANVAS_C.setMinimumWidth(300)
        self.CANVAS_C.setMaximumHeight(350)

        # print("canvas", self.CANVAS_C.extent)

        # Variable to store a rubberband formed by the current extents.
        self.RUBBER_CDB_SCHEMA_C = QgsRubberBand(self.CANVAS_C, QgsWkbTypes.PolygonGeometry)
        self.RUBBER_DELETE_C = QgsRubberBand(self.CANVAS_C, QgsWkbTypes.PolygonGeometry)

        # Enhance various Qt Objects with their initial text. 
        # This is used in order to revert to the original state in reset operations when original text has already changed.

        ### TAB Connection
        self.btnConnectToDbC.init_text = c.btnConnectToDbC_t

        self.btnCleanUpSchema.init_text = c.btnCleanUpSchema_t

        self.btnRefreshCDBExtents.init_text = c.btnRefreshCDBExtents_t
        self.btnCityExtents.init_text = c.btnCityExtents_t

        self.btnDelSelFeatures.init_text = c.btnDelSelFeatures_t

        ################################################
        ### SIGNALS (start) ############################

        #### 'User Connection' tab

        # 'Connection' group box signals
        self.cbxExistingConnC.currentIndexChanged.connect(lambda: self.evt_cbxExistingConn_changed(cdbMain))
        
        self.btnNewConnC.clicked.connect(self.evt_btnNewConn_clicked)

        # 'Database' group box signals
        self.btnConnectToDbC.clicked.connect(lambda: self.evt_btnConnectToDb_clicked(cdbMain))
        self.cbxSchema.currentIndexChanged.connect(lambda: self.evt_cbxSchema_changed(cdbMain))

        # 'Cleanup schema' group box signals
        self.gbxCleanUpSchema.toggled.connect(lambda: self.evt_gbxCleanUpSchema_toggled(cdbMain))
        self.btnCleanUpSchema.clicked.connect(lambda: self.evt_btnCleanUpSchema_clicked(cdbMain))


        # Basemap (OSM) group box signals
        # 'Base map' group box signals    
        self.gbxBasemapC.toggled.connect(lambda: self.evt_gbxBasemapC_toggled(cdbMain))

        # Link the additional canvas to the extents qgroupbox and enable "MapCanvasExtent" options (Byproduct).
        self.qgbxExtentsC.setMapCanvas(canvas=self.CANVAS_C, drawOnCanvasOption=False)

        # Draw on Canvas tool is disabled.
        # Check Note on main>widget_setup>ws_layers_tab.py>qgbxExtents_setup
        self.qgbxExtentsC.setOutputCrs(outputCrs=self.CRS)
        # 'Extents' groupbox signals
        self.qgbxExtentsC.extentChanged.connect(lambda: self.evt_qgbxExtentsC_ext_changed(cdbMain))
        self.CANVAS_C.extentsChanged.connect(self.evt_canvasC_ext_changed)

        self.btnRefreshCDBExtents.clicked.connect(lambda: self.evt_btnRefreshCDBExtents_clicked(cdbMain))
        self.btnCityExtents.clicked.connect(lambda: self.evt_btnCityExtents_clicked(cdbMain))

        self.btnGeoCoder.clicked.connect(self.evt_btnGeoCoder_clicked)


        # 'Feature selection' group box signals    
        self.gbxFeatSel.toggled.connect(lambda: self.evt_gbxFeatSel_toggled(cdbMain))

        self.gbxFeatType.toggled.connect(lambda: self.evt_gbxFeatType_toggled(cdbMain))
        # self.ccbxFeatType.currentIndexChanged.connect(lambda: self.evt_ccbxFeatType_changed(cdbMain))
        self.ckbFeatTypeAll.toggled.connect(lambda: self.evt_ckbFeatTypeAll_toggled(cdbMain))

        self.gbxRootClass.toggled.connect(lambda: self.evt_gbxRootClass_toggled(cdbMain))
        # self.ccbxRootClass.currentIndexChanged.connect(lambda: self.evt_ccbxRootClass_changed(cdbMain))
        self.ckbRootClassAll.toggled.connect(lambda: self.evt_ckbRootClassAll_toggled(cdbMain))

        self.btnDelSelFeatures.clicked.connect(lambda: self.evt_btnDelSelFeatures_clicked(cdbMain))

        # 'Close connection' group box signals  
        self.btnCloseConnC.clicked.connect(lambda: self.evt_btnCloseConnC_clicked(cdbMain))

        #### 'Settings' tab
        self.btnResetToDefault.clicked.connect(lambda: self.evt_btnResetToDefault_clicked(cdbMain))
        self.btnSaveSettings.clicked.connect(lambda: self.evt_btnSaveSettings_clicked(cdbMain))
        self.btnLoadSettings.clicked.connect(lambda: self.evt_btnLoadSettings_clicked(cdbMain))

        ### SIGNALS (end) ##############################
        ################################################

    ################################################
    ### EVENTS (start) ############################

    ## Events for 'User connection' tab BEGIN

    #'Connection' group box events (in 'User Connection' tab)
    def evt_cbxExistingConn_changed(self, cdbMain: CDBToolsMain) -> None:
        """Event that is called when the 'Existing Connection' comboBox (cbxExistingConnC) current index changes.
        This function runs every time the current selection of 'Existing Connection' changes.
        """
        # Set the current database connection object variable
        cdbMain.DB: Connection = self.cbxExistingConnC.currentData()
        if not cdbMain.DB:
            return None

        # Reset the tabs
        ts_wf.tabSettings_reset(cdbMain)
        tc_wf.tabConnection_reset(cdbMain)

        # Reset and (re)enable the "3D City Database" connection box and buttons
        # Enable the group box "Database" and reset the label, enable the Connect button, e
        self.gbxDatabase.setDisabled(False)   
        self.btnConnectToDbC.setText(self.btnConnectToDbC.init_text.format(db=cdbMain.DB.database_name))
        self.btnConnectToDbC.setDisabled(False)  # Enable the button 
        # self.lblConnectToDB.setDisabled(False)


    def evt_btnNewConn_clicked(self) -> None:
        """Event that is called when the 'New Connection' pushButton
        (btnNewConnC) is pressed.

        Responsible to add a new VALID connection to the 'Existing connections'.
        """
        # Create/Show/Execute additional dialog for the new connection
        dlgConnector = DBConnectorDialog()
        dlgConnector.setWindowModality(Qt.ApplicationModal) # i.e. 2, the window is modal to the application and blocks input to all windows.
        dlgConnector.show()
        dlgConnector.exec_()

        # Add new connection to the Existing connections
        if dlgConnector.conn_params:
            self.cbxExistingConnC.addItem(f"{dlgConnector.conn_params.connection_name}", dlgConnector.conn_params)


    # 'Database' group box events (in 'User Connection' tab)
    def evt_btnConnectToDb_clicked(self, cdbMain: CDBToolsMain) -> None:
        """Event that is called when the current 'Connect to {db}' pushButton
        (btnConnectToDbC) is pressed. It sets up the GUI after a click signal is emitted.
        """
        # Variable to store the plugin main dialog.
        dlg = cdbMain.deleter_dlg

        msg: str = None

        # In 'Connection Status' groupbox
        # Activate the connection status box (red/green checks)
        self.gbxConnStatusC.setDisabled(False)
        # Activate the close connection button at the bottom 
        self.btnCloseConnC.setDisabled(False) 

        # -------------------------------------------------------------------------------------------
        # Series of tests to be carried out when I connect as user.
        #
        # 1) Can I connect to the database? If yes, continue
        # 2) Can I connect to the qgis_pkg (and access its functions?) If yes, continue.
        # 3) Is the installed QGIS package version compatible with this version of the plugin? If yes, continue
        # 4) Is my qgis_user schema installed? It is required to store the settings
        # 5) Are there non-empty cdb_schemas I am allowed to connect to? If yes, continue
        # 6) Can I connect with RW privileges to at least one non-empty cdb_schema? If yes, continue
        # ########### Currently, the next check is not necessary (anymore), the limitation is overcome
        # 7) Am I a superuser? Take note, as only superusers can truncate tables (limit of 3DCityDB current implementation)
        # -------------------------------------------------------------------------------------------

        # 1) Can I connect to the database? If yes, continue

        # Attempt to connect to the database, returns True/False, and if successful, store connection in cdbMain.conn
        # Additionally, set cdbMain.DB.pg_server_version
        successful_connection: bool = conn_f.open_connection(cdbMain)

        if successful_connection:
            # Show database name
            self.lblConnToDbC_out.setText(c.success_html.format(text=cdbMain.DB.database_name))
            self.checks.is_conn_successful = True

            if cdbMain.DB.pg_server_version is not None:
                # Show server version
                self.lblPostInstC_out.setText(c.success_html.format(text=cdbMain.DB.pg_server_version))
            else:
                self.lblPostInstC_out.setText(c.failure_html.format(text=c.PG_SERVER_FAIL_MSG))
                return None # Exit

        else: # Connection failed!
            tc_wf.gbxConnStatus_reset(cdbMain)
            self.gbxConnStatusC.setDisabled(False)
            self.lblConnToDbC_out.setText(c.failure_html.format(text=c.CONN_FAIL_MSG))
            self.checks.is_conn_successful = False

            msg = f"The selected connection to the PostgreSQL server cannot be established. Please check whether it is still valid: the connection parameters may have to be updated!"
            QMessageBox.warning(self, "Connection error", msg)

            ts_wf.tabSettings_reset(cdbMain)
            tc_wf.tabConnection_reset(cdbMain)
            # Close the current open connection.
            if cdbMain.conn is not None:
                cdbMain.conn.close()

            return None # Exit

        # 2) Can I connect to the qgis_pkg (and access its functions?) If yes, continue.

        # Check if the qgis_pkg schema (main installation) is installed in database.
        is_qgis_pkg_installed: bool = sh_sql.is_qgis_pkg_installed(cdbMain)

        if is_qgis_pkg_installed:
            # I can now access the functions of the qgis_pkg (at least the public ones)
            # Set the current usr_schema name in cdbMain.USR_SCHEMA.
            sh_sql.exec_create_qgis_usr_schema_name(cdbMain)
        else:
            self.lblMainInstC_out.setText(c.failure_html.format(text=c.INST_FAIL_MISSING_MSG))
            self.checks.is_qgis_pkg_installed = False

            msg = f"The QGIS Package is either not installed in this database or you are not granted permission to use it.\n\nEither way, please contact your database administrator."
            QMessageBox.warning(self, "Unavailable QGIS Package", msg)

            ts_wf.tabSettings_reset(cdbMain)
            tc_wf.tabConnection_reset(cdbMain)
            # Close the current open connection.
            if cdbMain.conn is not None:
                cdbMain.conn.close()

            return None # Exit

        # 3) Is the installed QGIS package version compatible with this version of the plugin? If yes, continue

        # Get the current qgis_pkg version and check that it is compatible.
        # Named tuple: version, full_version, major_version, minor_version, minor_revision, code_name, release_date
        qgis_pkg_curr_version = sh_sql.exec_qgis_pkg_version(cdbMain)

        # print(qgis_pkg_curr_version)
        qgis_pkg_curr_version_txt      : str = qgis_pkg_curr_version.version
        qgis_pkg_curr_version_major    : int = qgis_pkg_curr_version.major_version
        qgis_pkg_curr_version_minor    : int = qgis_pkg_curr_version.minor_version
        qgis_pkg_curr_version_minor_rev: int = qgis_pkg_curr_version.minor_revision

        #############################################################
        # Only for testing purposes
        # qgis_pkg_curr_version_txt      : str = "0.7.3"
        # qgis_pkg_curr_version_major    : int = 0
        # qgis_pkg_curr_version_minor    : int = 7
        # qgis_pkg_curr_version_minor_rev: int = 3
        #############################################################

        # Check that the QGIS Package version is >= than the minimum required for this versin of the plugin (see cdb4_constants.py)
        if all((qgis_pkg_curr_version_major == c.QGIS_PKG_MIN_VERSION_MAJOR, 
                qgis_pkg_curr_version_minor == c.QGIS_PKG_MIN_VERSION_MINOR, 
                qgis_pkg_curr_version_minor_rev >= c.QGIS_PKG_MIN_VERSION_MINOR_REV)):

            # Show message in Connection Status the Qgis Package is installed (and version)
            self.lblMainInstC_out.setText(c.success_html.format(text=" ".join([c.INST_MSG, f"(v.{qgis_pkg_curr_version_txt})"]).format(pkg=cdbMain.QGIS_PKG_SCHEMA)))
            self.checks.is_qgis_pkg_installed = True
        else:
            self.lblMainInstC_out.setText(c.failure_html.format(text=c.INST_FAIL_VERSION_MSG))
            self.checks.is_qgis_pkg_installed = False

            msg: str = f"The current version of the QGIS Package installed in this database is {qgis_pkg_curr_version_txt} and is not supported anymore.\nPlease contact your database administrator and update the QGIS Package to version {c.QGIS_PKG_MIN_VERSION_TXT} (or higher)."
            QMessageBox.warning(dlg, "Unsupported version of QGIS Package", msg)

            ts_wf.tabSettings_reset(cdbMain)
            tc_wf.tabConnection_reset(cdbMain)
            # Close the current open connection.
            if cdbMain.conn is not None:
                cdbMain.conn.close()

            return None # Exit

        # 4) Is my usr_schema installed? If yes, continue.

        # Check if qgis_{usr} schema (e.g. qgis_giorgio) is installed in the database.
        is_usr_schema_inst: bool = sh_sql.is_usr_schema_installed(cdbMain)

        if is_usr_schema_inst:
            # Show message in Connection Status the 3DCityDB version if installed
            cdbMain.DB.citydb_version: str = sh_sql.fetch_3dcitydb_version(cdbMain)
            self.lbl3DCityDBInstC_out.setText(c.success_html.format(text=cdbMain.DB.citydb_version))
            self.checks.is_3dcitydb_installed = True

            # Show message in Connection Status that the qgis_{usr} schema is installed               
            self.lblUserInstC_out.setText(c.success_html.format(text=c.INST_MSG.format(pkg=cdbMain.USR_SCHEMA)))
            self.checks.is_usr_pkg_installed = True
        else:
            self.lblUserInstC_out.setText(c.failure_html.format(text=c.INST_FAIL_MSG.format(pkg=f"qgis_{cdbMain.DB.username}")))
            self.checks.is_usr_pkg_installed = False

            msg = f"The required user schema 'qgis_{cdbMain.DB.username}' is missing. Please contact your database administrator to install it."
            QMessageBox.warning(dlg, "User schema not found", msg)

            ts_wf.tabSettings_reset(cdbMain)
            tc_wf.tabConnection_reset(cdbMain)
            # Close the current open connection.
            if cdbMain.conn is not None:
                cdbMain.conn.close()

            return None # Exit

        # 5) Are there cdb_schemas I am allowed to connect to? If yes, continue
        # 6) Can I connect with RW privileges to at least one non-empty cdb_schema? If yes, continue

        # Get the list of 3DCityDB schemas from database as a tuple. If empty, len(tuple)=0
        # Namedtuple with: cdb_schema, co_number, priv_type
        cdb_schemas_extended = sql.exec_list_cdb_schemas_extended(cdbMain)
        # print('cdb_schema_extended', cdb_schemas_extended)

        # Select tuples of cdb_schemas that have number of cityobjects <> 0
        # AND the user has 'rw' privileges.
        cdb_schemas_rw: list = []
        cdb_schemas: list = [] 
        cdb_schemas_rw = [cdb_schema for cdb_schema in cdb_schemas_extended if cdb_schema.priv_type == 'rw']
        cdb_schemas = [cdb_schema for cdb_schema in cdb_schemas_rw if cdb_schema.co_number != 0]

        if len(cdb_schemas_rw) == 0: 
            # Inform the user that there are no cdb_schemas to be chosen from.
            msg: str = f"No citydb schemas could be retrieved from the database for which you have read & write privileges.\nPlease contact your database administrator."
            QMessageBox.warning(dlg, "No accessible citydb schemas found", msg)
            return None # Exit
        else:
            if len(cdb_schemas) == 0:
                tc_f.fill_cdb_schemas_box(cdbMain, None)
                
                # Inform the use that all available cdb_schemas are empty.
                msg = "The available citydb schema(s) is/are all empty. Please load data into the database first."
                QMessageBox.warning(dlg, "Empty citydb schema(s)", msg)

                ts_wf.tabSettings_reset(cdbMain)
                tc_wf.tabConnection_reset(cdbMain)
                # Close the current open connection.
                if cdbMain.conn is not None:
                    cdbMain.conn.close()

                return None
            else: # Finally, we have all conditions to proceed: 

                # 7) Am I a superuser? Take note, as only superusers can truncate tables (limit of 3DCityDB current implementation)
                # At the moment, this check is not needed anymore, as we allow users with RW to truncate the database, too.
                # Should be this decision be changed, then actually only superusers are allowed to truncate tables

                # We can start:

                # 1) Initialize the registries
                tc_f.initialise_root_class_features_registry(cdbMain)
                tc_f.initialize_feature_types_registry(cdbMain)

                # 2) Fill the cdb_schema combobox
                tc_f.fill_cdb_schemas_box(cdbMain, cdb_schemas)
                # At this point, filling the schema box, activates the 'evt_cbxSchema_changed' event.

        return None # Exit


    def evt_cbxSchema_changed(self, cdbMain: CDBToolsMain) -> None:
        """Event that is called when the 'schemas' comboBox (cbxSchema) current index changes.
        Function to setup the GUI after an 'indexChanged' signal is emitted from the cbxSchema combo box.
        This function runs every time the selected schema is changed (in 'User Connection' tab)
        Checks if the connection + schema meet the necessary requirements.
        """
        # Set the current schema variable
        cdbMain.CDB_SCHEMA: str = self.cbxSchema.currentText()
        # By now, the schema variable must have beeen assigned. Check:
        if not self.cbxSchema.currentData():
            return None

        # Reset the Settings tabs in case they were open/changed from before 
        ts_wf.tabSettings_reset(cdbMain) # Reset the Settings tab to the Default settings
        tc_wf.gbxCleanUpSchema_reset(cdbMain)
        tc_wf.gbxBasemapC_reset(cdbMain)        
        tc_wf.gbxFeatSel_reset(cdbMain)

        self.CDB_SCHEMA_EXTENTS = QgsRectangle()
        self.DELETE_EXTENTS = QgsRectangle()

        # Update labels with the name of the selected cdb_schema
        self.btnCleanUpSchema.setText(self.btnCleanUpSchema.init_text.format(sch=cdbMain.CDB_SCHEMA))

        self.btnRefreshCDBExtents.setText(self.btnRefreshCDBExtents.init_text.format(sch=cdbMain.CDB_SCHEMA))
        self.btnCityExtents.setText(self.btnCityExtents.init_text.format(sch=cdbMain.CDB_SCHEMA))
        
        self.btnDelSelFeatures.setText(self.btnDelSelFeatures.init_text.format(sch=cdbMain.CDB_SCHEMA)) 

        # Enable the settings tab
        self.tabSettings.setDisabled(False)

        # Enable the Cleanup Schema groupbox
        self.gbxCleanUpSchema.setDisabled(False)
        # Enable the Base Map groupbox
        self.gbxBasemapC.setDisabled(False)

        # Enable the Feature Selection groupbox
        self.gbxFeatSel.setDisabled(False)

        # Setup the 'Basemap (OSM)' groupbox.
        tc_wf.gbxBasemapC_setup(cdbMain)
        # This will eventually fire a evt_qgbxExtentsC_ext_changed event

        tc_wf.gbxFeatType_reset(cdbMain)
        tc_wf.gbxRootClass_reset(cdbMain)

        return None


    def evt_gbxCleanUpSchema_toggled(self, cdbMain: CDBToolsMain) -> None:
        """Event that is called when the groupbox 'Feature Selection' is toggled.
        """
        status: bool = self.gbxCleanUpSchema.isChecked()

        tc_wf.gbxFeatType_reset(cdbMain)
        tc_wf.gbxRootClass_reset(cdbMain)

        if status: # it is checked to be enabled
            # Enable the button
            self.btnCleanUpSchema.setDisabled(False)

            # Disable the groupbox gbxBasemapC
            self.gbxBasemapC.setDisabled(True)

            # Disable the FeatureSelection group box 
            self.gbxFeatSel.setDisabled(True)

        else: # if unchecked, it disables itself automatically
            # Disable the button
            self.btnCleanUpSchema.setDisabled(True)

            # Enable the groupbox gbxBasemapC
            self.gbxBasemapC.setDisabled(False)
            # Enable the Feature Selection group box
            self.gbxFeatSel.setDisabled(False)

        return None


    def evt_btnCleanUpSchema_clicked(self, cdbMain: CDBToolsMain) -> None:
        """Event that is called when the 'Truncate tables' button (btnCleanUpSchema) is pressed.
        """
        msg1: str = f"All tables in citydb schema {cdbMain.CDB_SCHEMA} will be truncated and all data will be deleted.\n\nDo you really want to proceed?"
        msg2: str = f"ALL tables in citydb schema {cdbMain.CDB_SCHEMA} will be truncated and ALL data will be deleted.\n\nDo you REALLY want to proceed?"
        msg3: str = f"ALL tables in citydb schema {cdbMain.CDB_SCHEMA} will be truncated and ALL data will be deleted FOREVER.\n\nDo you REALLY REALLY want to proceed?\n\nIf you'll loose data, don't tell we didn't warn you..."
        res = QMessageBox.question(self, "Clean up citydb schema", msg1)
        if res == 16384: #YES
            res = QMessageBox.question(self, "Clean up citydb schema", msg2)
            if res == 16384: #YES
                res = QMessageBox.question(self, "Clean up citydb schema", msg3)
                if res == 16384: #YES               
                    thr.run_cleanup_schema_thread(cdbMain)
        return None


    def evt_gbxBasemapC_toggled(self, cdbMain: CDBToolsMain) -> None:
        """Event that is called when the groupbox 'gbxBasemapC' is toggled.
        """
        status: bool = self.gbxBasemapC.isChecked()

        if status: # it is checked to be enabled
            # (Re) Setup the 'Basemap (OSM)' groupbox.
            tc_wf.gbxBasemapC_setup(cdbMain) # fires a evt_qgbxExtentsC_ext_changed() event
            self.gvCanvasC.setDisabled(False)
            self.qgbxExtentsC.setDisabled(False)
            # Enable the "Set to schema" button
            self.btnCityExtents.setDisabled(False)
            # Enable the Refresh extents button
            self.btnRefreshCDBExtents.setDisabled(False)
            # Enable the "Geocoder" button
            self.btnGeoCoder.setDisabled(False)

            # tc_wf.workaround_gbxFeatType(cdbMain)
            # tc_wf.workaround_gbxRootClass(cdbMain)

            if self.gbxFeatSel.isChecked():
                # Both are unchecked: leave them disabled
                if not self.gbxFeatType.isChecked() and not self.gbxRootClass.isChecked():
                    self.gbxFeatType.setDisabled(False)
                    self.gbxRootClass.setDisabled(False)
                # FeatType is checked: leave it enabled, disable the other
                if self.gbxFeatType.isChecked() and not self.gbxRootClass.isChecked():
                    self.gbxFeatType.setDisabled(False)
                    self.gbxRootClass.setDisabled(True)
                # RootClass is checked: leave it enabled, disable the other
                if not self.gbxFeatType.isChecked() and self.gbxRootClass.isChecked():
                    self.gbxFeatType.setDisabled(True)
                    self.gbxRootClass.setDisabled(False)

        else: # when unchecked, it disables itself automatically
            # We do not want to completely reset the groupbox (it would delete all, and clean the canvas, too)
            # So, we selectively disable some stuff.
            self.gvCanvasC.setDisabled(True)
            self.qgbxExtentsC.setDisabled(True)
            # Disable the "Set to schema" button
            self.btnCityExtents.setDisabled(True)
            # Disable the Refresh extents button
            self.btnRefreshCDBExtents.setDisabled(True)
            # Disable the "Geocoder" button
            self.btnGeoCoder.setDisabled(True)

            # Remove extent rubber bands.
            # self.RUBBER_CDB_SCHEMA_C.reset()
            # self.RUBBER_DELETE_C.reset()

            # Reset the current extents to those of the cdb_schema
            self.CURRENT_EXTENTS = self.CDB_SCHEMA_EXTENTS

            # Then update canvas with cdb_schema extents and crs, this fires the gbcExtent event
            canvas.canvas_setup(cdbMain=cdbMain, canvas=self.CANVAS_C, extents=self.CURRENT_EXTENTS, crs=self.CRS, clear=True)

            # Zoom to the cdb_schema extents
            canvas.zoom_to_extents(canvas=self.CANVAS_C, extents=self.CDB_SCHEMA_EXTENTS)

        return None


    def evt_canvasC_ext_changed(self) -> None:
        """Event that is called when the current canvas extents (pan over map) changes.
        Reads the new current extents from the map and sets it in the 'Extents'
        (qgbxExtentsC) widget.
        """
        # Get canvas's current extent
        extent: QgsRectangle = self.CANVAS_C.extent()

        # Set the current extent to show in the 'extents' widget.
        self.qgbxExtentsC.blockSignals(True)
        self.qgbxExtentsC.setOutputCrs(outputCrs=self.CRS) # Signal emitted for qgbxExtentsC. Avoid double signal blocking signals
        self.qgbxExtentsC.blockSignals(False)
        self.qgbxExtentsC.setCurrentExtent(currentExtent=extent, currentCrs=self.CRS) # Signal emitted for qgbxExtentsC

        return None


    def evt_qgbxExtentsC_ext_changed(self, cdbMain: CDBToolsMain) -> None:
        """Event that is called when the 'Extents' groubBox extent (qgbxExtentsC) changes.
        """
        # Update current extents variable with the ones that fired the signal.
        self.CURRENT_EXTENTS: QgsRectangle = self.qgbxExtentsC.outputExtent()

        if self.CURRENT_EXTENTS.isNull() or self.CDB_SCHEMA_EXTENTS.isNull():
            return None

        # Check validity of user extents relative to the City Model's cdb_extents.
        delete_extents_poly = QgsGeometry.fromRect(self.CURRENT_EXTENTS)
        cdb_extents_poly = QgsGeometry.fromRect(self.CDB_SCHEMA_EXTENTS)

        if delete_extents_poly.intersects(cdb_extents_poly):
            self.DELETE_EXTENTS: QgsRectangle = self.CURRENT_EXTENTS

            # Draw the delete extents rubber band
            canvas.insert_rubber_band(band=self.RUBBER_DELETE_C, extents=self.DELETE_EXTENTS, crs=self.CRS, width=2, color=c.DELETE_EXTENTS_COLOUR)

            # print("from: evt_qgbxExtentsC_ext_changed")
            tc_f.refresh_registries(cdbMain)

        else:
            QMessageBox.critical(self, "Warning", f"Pick a region intersecting the extents of '{cdbMain.CDB_SCHEMA}' (black area).")

        return None


    def evt_btnRefreshCDBExtents_clicked(self, cdbMain: CDBToolsMain) -> None:
        """Event that is called when the button (btnRefreshCDBExtents) is pressed.
        It will check whether the cdb_extents
        - are null, i.e. the database has been emptied (reset all, the cdb_schema will disappear from the list)
        - have not changed (do nothing)
        - have changed and the new cdb extents contain the old ones (only update the ribbons)
        - have changed and the new cdb extents do not strictly contain the old ones (drop existing layers, update ribbons)
        """
        tc_f.refresh_extents(cdbMain)

        return None
   
 
    def evt_btnCityExtents_clicked(self, cdbMain: CDBToolsMain) -> None:
        """Event that is called when the current 'Calculate from City model' pushButton (btnCityExtents) is pressed.
        """
        # Get the extents stored in server (already computed at this point).
        cdb_extents_wkt: str = sql.fetch_precomputed_extents(cdbMain, usr_schema=cdbMain.USR_SCHEMA, cdb_schema=cdbMain.CDB_SCHEMA, ext_type=c.CDB_SCHEMA_EXT_TYPE)

        # Convert extents format to QgsRectangle object.
        cdb_extents = QgsRectangle.fromWkt(cdb_extents_wkt)
        # Update extents in plugin variable.
        self.CDB_SCHEMA_EXTENTS = cdb_extents
        self.CURRENT_EXTENTS = cdb_extents

        # Put extents coordinates into the widget.
        self.qgbxExtentsC.setOutputExtentFromUser(self.CURRENT_EXTENTS, self.CRS)
        # At this point an extents_changed signal is emitted.

        canvas.zoom_to_extents(canvas=self.CANVAS_C, extents=self.CDB_SCHEMA_EXTENTS)


    def evt_btnGeoCoder_clicked(self) -> None:
        """Event that is called when the 'Geocoder' button (btnGeoCoder) is pressed.
        """
        dlg_crs = self.CRS
        dlg_cdb_extents = self.CDB_SCHEMA_EXTENTS
        dlg_canvas = self.CANVAS_C

        dlgGeocoder = GeoCoderDialog(dlg_crs, dlg_cdb_extents, dlg_canvas)
        dlgGeocoder.setWindowModality(Qt.ApplicationModal) # i.e. 2 = The window blocks input to all other windows.
        dlgGeocoder.show()
        dlgGeocoder.exec_()

        return None


    def evt_gbxFeatSel_toggled(self, cdbMain: CDBToolsMain) -> None:
        """Event that is called when the groupbox 'Feature Selection' is toggled.
        """
        status: bool = self.gbxFeatSel.isChecked()

        if status: # it is checked to be enabled
            # Disable the gbxCleanUpSchema (if enabled)
            if self.gbxCleanUpSchema.isEnabled():
                self.gbxCleanUpSchema.setDisabled(True)

            if not self.gbxBasemapC.isEnabled():
            # Enable the groupbox gbxBasemapC
                self.gbxBasemapC.setDisabled(False)

            tc_wf.workaround_gbxFeatType(cdbMain)
            tc_wf.workaround_gbxRootClass(cdbMain)

            # Set up/update the "Select Features" group box
            tc_f.refresh_registries(cdbMain)

            # Enable the groupbox FeatType
            self.gbxFeatType.setDisabled(False)
            # Enable the groupbox RootClass
            self.gbxRootClass.setDisabled(False)

            # Enable the Delete Selected features button
            self.btnDelSelFeatures.setDisabled(False)


        else: # when unchecked, it disables itself automatically
            tc_wf.gbxFeatSel_reset(cdbMain) # it disables itself, I need to reenable it
            # (Re)enable the gbxFeatSel groupbox
            self.gbxFeatSel.setDisabled(False)

            # Uncheck the groupbox gbxBasemapC
            # self.gbxBasemapC.setChecked(False)
            # Disable the groupbox gbxBasemapC
            self.gbxBasemapC.setDisabled(False)

            # Enable the gbxCleanUpSchema group
            self.gbxCleanUpSchema.setDisabled(False)

        return None


    def evt_gbxFeatType_toggled(self, cdbMain: CDBToolsMain) -> None:
        """Event that is called when the groupbox 'Feature Type' is toggled.
        """
        status: bool = self.gbxFeatType.isChecked()

        if status: # it is checked to be enabled
            # Disable check box ckbRootClassAll
            self.ckbRootClassAll.setDisabled(True)
            # Diable checkable combo box ccbxRootClass
            self.ccbxRootClass.setDisabled(True)
            # Disable the gbxRootClass
            self.gbxRootClass.setDisabled(True)

            # Enable combo box cbxFeatType
            self.ccbxFeatType.setDisabled(False)
            # Enable check box ckbFeatTypeAll
            self.ckbFeatTypeAll.setDisabled(False)
            # Enable the gbxFeatType
            self.gbxFeatType.setDisabled(False)

        else: # when unchecked, it disables itself automatically
            # Disable check box ckbFeatTypeAll
            self.ckbFeatTypeAll.setChecked(False)            
            self.ckbFeatTypeAll.setDisabled(True)
            # Clear the previous selected items
            for i in range(self.ccbxFeatType.count()):
                self.ccbxFeatType.setItemCheckState(i, Qt.Unchecked)
            # Disable combo box cbxFeatType
            self.ccbxFeatType.setDisabled(True)

            # Enable the gbxRootClass
            self.gbxRootClass.setDisabled(False)
            # Keep disabled check box ckbRootClassAll
            self.ckbRootClassAll.setDisabled(True)
            # Keep disabled combobox cbxRootClass
            self.ccbxRootClass.setDisabled(True)

        return None


    def evt_ckbFeatTypeAll_toggled(self, cdbMain: CDBToolsMain) -> None:
        """Event that is called when the check box 'Feature Type All' is toggled.
        If checked, it will turn all entries to checked.
        If unchecked, it will set all entries to unchecked.
        """
        status: bool = self.ckbFeatTypeAll.isChecked()

        if status: # Selected/Checked
            # Select all items in combobox with cdb_schemas, set status to 2 (Checked)
            for i in range(self.ccbxFeatType.count()):
                 self.ccbxFeatType.setItemCheckState(i, Qt.Checked)
            # Disable the drop down menu
            self.ccbxFeatType.setDisabled(True)
        else:
            # Unselect all items in combobox with cdb_schemas, set status to 0 (Unchecked)
            for i in range(self.ccbxFeatType.count()):
                 self.ccbxFeatType.setItemCheckState(i, Qt.Unchecked)
            # Enable the drop down menu
            self.ccbxFeatType.setDisabled(False)
            
        return None


    def evt_gbxRootClass_toggled(self, cdbMain: CDBToolsMain) -> None:
        """Event that is called when the check box 'Root-Class Feature' is toggled.
        """
        status: bool = self.gbxRootClass.isChecked()

        if status: # it is checked to be enabled
            # Disable check box ckbFeatTypeAll
            self.ckbFeatTypeAll.setDisabled(True)
            # Disable checkable combo box cbxFeatType
            self.ccbxFeatType.setDisabled(True)
            # Disable the group box gbxFeatType
            self.gbxFeatType.setDisabled(True)

            # Enable check box ckbRootClassAll
            self.ckbRootClassAll.setDisabled(False)
            # Enable combo box ccbxRootClass
            self.ccbxRootClass.setDisabled(False)
            # Enable the groupbox gbxRootClass
            self.gbxRootClass.setDisabled(False)

        else: # when unchecked, it disables itself automatically
            # Disable check box ckbFeatTypeAll
            self.ckbRootClassAll.setChecked(False)
            self.ckbRootClassAll.setDisabled(True)
            # Clear the previous selected items
            for i in range(self.ccbxRootClass.count()):
                self.ccbxRootClass.setItemCheckState(i, Qt.Unchecked)
            # Disable combo box cbxFeatType
            self.ccbxRootClass.setDisabled(True)

            # Enable the group box gbxFeatType
            self.gbxFeatType.setDisabled(False)
            # Keep disabled check box ckbFeatTypeAll
            self.ckbFeatTypeAll.setDisabled(True)
            # Kepp disabled checkable combo box cbxFeatType
            self.ccbxFeatType.setDisabled(True)

        return None


    def evt_ckbRootClassAll_toggled(self, cdbMain: CDBToolsMain) -> None:
        """Event that is called when the check box 'Root-Class Feature All' is toggled.
        If checked, it will turn all entries to checked.
        If unchecked, it will set all entries to unchecked.
        """
        status: bool = self.ckbRootClassAll.isChecked()

        if status: # Selected/Checked
            # Select all items in combobox with cdb_schemas, set status to 2 (Checked)
            for i in range(self.ccbxRootClass.count()):
                 self.ccbxRootClass.setItemCheckState(i, Qt.Checked)
            # Disable the drop down menu
            self.ccbxRootClass.setDisabled(True)
        else:
            # Unselect all items in combobox with cdb_schemas, set status to 0 (Unchecked)
            for i in range(self.ccbxRootClass.count()):
                 self.ccbxRootClass.setItemCheckState(i, Qt.Unchecked)
            # Enable the drop down menu
            self.ccbxRootClass.setDisabled(False)

        return None


    def evt_btnDelSelFeatures_clicked(self, cdbMain: CDBToolsMain) -> None:
        """Event that is called when the 'Delete selected features from schema {sch}' button (btnDelSelFeatures) is pressed.
        """
        delete_mode: str = None # Eiter "del_FeatureTypes" or "del_RootClassFeatures"

        # Check that there are indeed some features selected

        if all((not self.gbxFeatType.isChecked(),
                not self.gbxRootClass.isChecked())):
            msg: str = "You must enable either the 'Feature types' or the 'Root-class features' boxes."
            res = QMessageBox.warning(self, "Missing selection", msg)
            return None # Exit
        
        elif self.gbxFeatType.isChecked():
            # Get the list (tuple) of selected Feature Types in the current cdb_schema
            sel_feat_types: list = gen_f.get_checkedItemsData(self.ccbxFeatType)
            # print("Selected Feature Types:", sel_feat_types)

            if len(sel_feat_types) == 0:
                msg: str = "You must select at least a Feature Type from the combo box."
                res = QMessageBox.warning(self, "Missing selection", msg)
                return None # Exit
            else:
                delete_mode = "del_FeatureTypes"
                tc_f.update_feature_type_registry_is_selected(cdbMain, sel_feat_types)

        elif self.gbxRootClass.isChecked():
            # Get the list (tuple) of selected Root-class Features in the current cdb_schema
            sel_root_class_features: list = gen_f.get_checkedItemsData(self.ccbxRootClass)
            # print("Selected Root-class features:", sel_root_class_features)

            if len(sel_root_class_features) == 0:
                msg: str = "You must select at least a Root-class feature Type from the combo box."
                res = QMessageBox.warning(self, "Missing selection", msg)
                return None # Exit
            else:
                delete_mode = "del_RootClassFeatures"
                tc_f.update_root_class_features_is_selected(cdbMain, sel_root_class_features)

        else:
            # This case should not happen.
            print('This case should not happen.')
            return None # Exit

        msg1: str = f"Data will be deleted from citydb schema {cdbMain.CDB_SCHEMA}.\n\nDo you really want to proceed?"
        msg2: str = f"Data will be deleted from citydb schema {cdbMain.CDB_SCHEMA}.\n\nDo you REALLY want to proceed?"
        msg3: str = f"Data will be deleted from citydb schema {cdbMain.CDB_SCHEMA}.\n\nDo you REALLY REALLY want to proceed?\n\nIf you'll loose data, don't tell we didn't warn you..."
        res = QMessageBox.question(self, "Clean up citydb schema", msg1)
        if res == 16384: #YES
            res = QMessageBox.question(self, "Clean up citydb schema", msg2)
            if res == 16384: #YES
                res = QMessageBox.question(self, "Clean up citydb schema", msg3)
                if res == 16384: #YES               
                    # print(f"\nDeleting selected features from '{cdbMain.CDB_SCHEMA}'\n")

                    # This thread will also take care of checking what happens after deletion,
                    # e.g. in case that the database is completely emptied.
                    # The user will be eventually informed
                    thr.run_bulk_delete_thread(cdbMain, delete_mode)

                    # print(f"\nDeleted selected features from '{cdbMain.CDB_SCHEMA}'\n")

                    # Inform the user
                    # msg: str = f"Data successfully deleted from citydb schema '{cdbMain.CDB_SCHEMA}'"
                    # QgsMessageLog.logMessage(msg, cdbMain.PLUGIN_NAME, level=Qgis.Info, notifyUser=True)

        return None


    def evt_btnCloseConnC_clicked(self, cdbMain: CDBToolsMain) -> None:
        """Event that is called when the 'Close current connection' pushButton (btnCloseConn) is pressed.
        """
        ts_wf.tabSettings_reset(cdbMain)
        tc_wf.tabConnection_reset(cdbMain)

        # Close the current open connection.
        if cdbMain.conn is not None:
            cdbMain.conn.close()

    ## Events for User connection tab END

##################################################################################

    ## Events for Settings tab BEGIN

    def evt_btnResetToDefault_clicked(self, cdbMain: CDBToolsMain) -> None:
        """Event that is called when the button 'Reset to default values' is clicked
        """
        ts_wf.tabSettings_reset(cdbMain) # This also disables it and the buttons.
        # Reactivate it, as well as the buttons
        self.tabSettings.setDisabled(False)       

        return None


    def evt_btnSaveSettings_clicked(self, cdbMain: CDBToolsMain) -> None:
        """Event that is called when the button 'Save settings' is clicked
        """
        delArraySize = self.sbxArraySize.value()

        if all((delArraySize == self.settings.max_del_array_length_default,
                )):
            # No need to store the settings, they are unchanged. Inform the user
            msg: str = f"No need to store the settings, they coincide with the default values."
            QgsMessageLog.logMessage(msg, cdbMain.PLUGIN_NAME, level=Qgis.Info, notifyUser=True)
            return None # Exit

        # Quick reminder:
        # 1 string
        # 2 integer
        # 3 real
        # 4 boolean (cast to int())

        settings_list = []
        settings_list = [
            {'name': 'delArraySize' , 'data_type': 2, 'data_value': delArraySize , 'label': self.settings.max_del_array_length_label},
        ]
        # print(settings_list)

        res = sh_sql.exec_upsert_settings(cdbMain, cdbMain.USR_SCHEMA, self.DIALOG_NAME, settings_list)

        if not res:
            # Inform the user
            msg: str = f"Settings for '{self.DIALOG_NAME}' could not be saved!"
            QgsMessageLog.logMessage(msg, cdbMain.PLUGIN_NAME, level=Qgis.Warning, notifyUser=True)
            return None # Exit

        # Inform the user
        msg: str = f"Settings for '{self.DIALOG_NAME}' have been saved!"
        QgsMessageLog.logMessage(msg, cdbMain.PLUGIN_NAME, level=Qgis.Info, notifyUser=True)

        return None


    def evt_btnLoadSettings_clicked(self, cdbMain: CDBToolsMain) -> None:
        """Event that is called when the button 'Save settings' is clicked
        """
        settings_list = []
        settings_list = sh_sql.exec_read_settings(cdbMain, cdbMain.USR_SCHEMA, self.DIALOG_NAME)
        # print(settings_list)

        if not settings_list:
            # Inform the user
            msg: str = f"Settings for '{self.DIALOG_NAME}' could not be loaded!"
            QgsMessageLog.logMessage(msg, cdbMain.PLUGIN_NAME, level=Qgis.Warning, notifyUser=True)
            return None # Exit without updating the settings

        s: dict
        for s in settings_list:
            n = s['name']
            if n == "delArraySize":
                self.sbxArraySize.setValue(s["data_value"])
            else:
                pass

        # Inform the user
        msg: str = f"Settings for '{self.DIALOG_NAME}' have been loaded!"
        QgsMessageLog.logMessage(msg, cdbMain.PLUGIN_NAME, level=Qgis.Info, notifyUser=True)

        return None

    ### EVENTS (end) ############################