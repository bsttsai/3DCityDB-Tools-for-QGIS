# -*- coding: utf-8 -*-
"""
/***************************************************************************
 DBLoaderDialog
                                 A QGIS plugin
                    This is an experimental plugin for 3DCityDB.
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                             -------------------
        begin                : 2021-09-30
        git sha              : $Format:%H$
        copyright            : (C) 2021 by Konstantinos Pantelios
        email                : konstantinospantelios@yahoo.com
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""

from qgis.core import Qgis, QgsMessageLog
from qgis.core import QgsProject, QgsRectangle, QgsGeometry
from qgis.PyQt.QtCore import Qt
from qgis.PyQt.QtWidgets import QMessageBox 
from qgis.PyQt.QtGui import QTextDocument

import os
from qgis.PyQt import uic
from qgis.PyQt import QtWidgets

from ...cdb_loader import CDBLoader # Used only to add the type of the function parameters

from ..gui_db_connector.db_connection_dialog import DBConnectorDialog
from ..gui_db_connector.functions import conn_functions as conn_f

from ... import main_constants as main_c
from .. import cdb4_constants as c

from .functions import tab_conn_widget_functions as ct_wf
from .functions import tab_conn_functions as uc_tf

from .functions import tab_layers_widget_functions as lt_wf
from .functions import tab_layers_functions as l_tf

from .functions import canvas, sql, threads as thr

# This loads the .ui file so that PyQt can populate the plugin
# with the elements from Qt Designer
FORM_CLASS, _ = uic.loadUiType(os.path.join(
    os.path.dirname(__file__), "ui", "cdb4_loader_user_dialog.ui"))

class CDB4LoaderUserDialog(QtWidgets.QDialog, FORM_CLASS):
    """User Dialog class of the plugin.
    The GUI is imported from an external .ui xml
    """

    def __init__(self, cdbLoader: CDBLoader, parent=None):
        """Constructor."""
        super(CDB4LoaderUserDialog, self).__init__(parent)
        # Set up the user interface from Designer through FORM_CLASS.
        # After self.setupUi() you can access any designer object by doing
        # self.<objectname>, and you can use autoconnect slots - see
        # http://qt-project.org/doc/qt-4.8/designer-using-a-ui-file.html
        # #widgets-and-dialogs-with-auto-connect
        self.setupUi(self)

        # Enhance various Qt Objects with their initial text.
        # This is used in order to revert to the original state
        # in reset operations when original text has already changed.
    
        ########### Stub written by Giorgio to load the html text of the about tab from a file ###########
        # tababout_text = QTextDocument()
        # f_path = os.path.join(os.path.dirname(__file__), "tababout.html")
        # with open(f_path, 'r', encoding = 'utf-8') as f:
        #      #QgsMessageLog.logMessage(f"html file {f.read()}", "Messages", level=Qgis.Info)
        #      tababout_text.setHtml(f.read())
        # self.aboutTextBrowser.setDocument(tababout_text)
        # #QgsMessageLog.logMessage(f"about tab {self.aboutTextBrowser.toHtml()}", "Messages", level=Qgis.Info)
        ##################################################################################################

        self.btnConnectToDbC.init_text = c.btnConnectToDbC_t
        self.btnCreateLayers.init_text = c.btnCreateLayers_t
        self.btnRefreshLayers.init_text = c.btnRefreshLayers_t
        self.btnDropLayers.init_text = c.btnDropLayers_t
        self.btnCityExtentsC.init_text = c.btnCityExtentsC_t
        
        self.lblInfoText.init_text = c.lblInfoText_t
        self.btnCityExtents.init_text = c.btnCityExtents_t
        self.ccbxFeatures.init_text = c.ccbxFeatures_t

        ### SIGNALS (start) ############################

        #### 'User Connection' tab

        # 'Connection' group box signals
        self.cbxExistingConnC.currentIndexChanged.connect(lambda: self.evt_cbxExistingConn_changed(cdbLoader))
        
        #self.btnNewConnC.clicked.connect(self.evt_btnNewConn_clicked)
        self.btnNewConnC.clicked.connect(lambda: self.evt_btnNewConn_clicked(cdbLoader))

        # 'Database' group box signals
        self.btnConnectToDbC.clicked.connect(lambda: self.evt_btnConnectToDb_clicked(cdbLoader))
        self.cbxSchema.currentIndexChanged.connect(lambda: self.evt_cbxSchema_changed(cdbLoader))

        # Basemap (OSM) group box signals
        # Link the addition canvas to the extents qgroupbox and
        # enable "MapCanvasExtent" options (Byproduct).
        self.qgbxExtentsC.setMapCanvas(canvas=cdbLoader.CANVAS_C, drawOnCanvasOption = False)

        # Draw on Canvas tool is disabled.
        # Check Note on main>widget_setup>ws_layers_tab.py>qgbxExtents_setup
        self.qgbxExtentsC.setOutputCrs(outputCrs=cdbLoader.CRS)

        # 'Extents' groupbox signals
        self.btnCityExtentsC.clicked.connect(lambda: self.evt_btnCityExtentsC_clicked(cdbLoader))
        cdbLoader.CANVAS_C.extentsChanged.connect(lambda: self.evt_canvas_ext_changed(cdbLoader))
        self.qgbxExtentsC.extentChanged.connect(lambda: self.evt_qgbxExtentsC_ext_changed(cdbLoader))

        self.btnCreateLayers.clicked.connect(lambda: self.evt_btnCreateLayers_clicked(cdbLoader))
        self.btnRefreshLayers.clicked.connect(lambda: self.evt_btnRefreshLayers_clicked(cdbLoader))
        self.btnDropLayers.clicked.connect(lambda: self.evt_btnDropLayers_clicked(cdbLoader))

        self.btnCloseConnC.clicked.connect(lambda: self.evt_btnCloseConnC_clicked(cdbLoader))

        #### 'Layer ' tab
        
        #Link the addition canvas to the extents qgroupbox and
        #enable "MapCanvasExtent" options (Byproduct).
        self.qgbxExtents.setMapCanvas(canvas=cdbLoader.CANVAS, drawOnCanvasOption=False)
        #Draw on Canvas tool is disabled.
        #Check Note on main>widget_setup>ws_layers_tab.py>qgbxExtents_setup
        self.qgbxExtents.setOutputCrs(outputCrs=cdbLoader.CRS)

        # 'Extents' groupbox signals (in 'Layers' tab)
        self.qgbxExtents.extentChanged.connect(lambda: self.evt_qgbxExtents_extChanged(cdbLoader))
        self.btnCityExtents.clicked.connect(lambda: self.evt_btnCityExtents_clicked(cdbLoader))          

        # 'Parameters' groupbox signals (in 'Layers' tab)
        self.cbxFeatureType.currentIndexChanged.connect(lambda: self.evt_cbxFeatureType_changed(cdbLoader))
        self.cbxLod.currentIndexChanged.connect(lambda: self.evt_cbxLod_changed(cdbLoader))

        # 'Features to Import' groupbox signals (in 'Layers' tab)
        self.ccbxFeatures.checkedItemsChanged.connect(lambda: self.evt_cbxFeatures_changed(cdbLoader))
        self.btnImport.clicked.connect(lambda: self.evt_btnImport_clicked(cdbLoader))

        ### SIGNALS (end) ############################


    ### EVENTS (start) ############################

    ## Events for 'User connection' tab BEGIN

    #'Connection' group box events (in 'User Connection' tab)
    def evt_cbxExistingConn_changed(self, cdbLoader: CDBLoader) -> None:
        """Event that is called when the 'Existing Connection'
        comboBox (cbxExistingConnC) current index changes.
        This function sets up runs every time the current selection of 
        'Existing Connection' changes.
        """
        # Set the current database connection object variable
        cdbLoader.DB = self.cbxExistingConnC.currentData()
        if not cdbLoader.DB:
            return None

        #ct_wf.cbxExistingConn_setup(cdbLoader)

        dlg = cdbLoader.usr_dlg

        ct_wf.tabConnection_reset(cdbLoader)
        lt_wf.tabLayers_reset(cdbLoader)

        dlg.gbxDatabase.setDisabled(False)
        dlg.btnConnectToDbC.setText(dlg.btnConnectToDbC.init_text.format(db=cdbLoader.DB.database_name))
        dlg.btnConnectToDbC.setDisabled(False)
        dlg.lblConnectToDB.setDisabled(False)

        # Close the current open connection.
        if cdbLoader.conn is not None:
            cdbLoader.conn.close()


    def evt_btnNewConn_clicked(self, cdbLoader: CDBLoader) -> None:
        """Event that is called when the 'New Connection' pushButton
        (btnNewConnC) is pressed.

        Resposible to add a new VALID connection to the 'Existing connections'.
        """
        # Create/Show/Execute additional dialog for the new connection
        dlgConnector = DBConnectorDialog()
        dlgConnector.setWindowModality(2)
        dlgConnector.show()
        dlgConnector.exec_()

        # Variable to store the plugin main dialog.
        dlg = cdbLoader.usr_dlg

        # Add new connection to the Existing connections
        if dlgConnector.new_connection:
            dlg.cbxExistingConnC.addItem(
                f"{dlgConnector.new_connection.connection_name}",
                dlgConnector.new_connection)
                #dlgConnector.close()


    # 'Database' group box events (in 'User Connection' tab)
    def evt_btnConnectToDb_clicked(self, cdbLoader: CDBLoader) -> None:
        """Event that is called when the current 'Connect to {db}' pushButton
        (btnConnectToDbC) is pressed.
        It sets up the GUI after a click signal is emitted.
        """

        #ct_wf.btnConnectToDb_setup(cdbLoader)

        # Variable to store the plugin main dialog.
        dlg = cdbLoader.usr_dlg

        #In 'Connection Status' groupbox
        dlg.gbxConnStatusC.setDisabled(False)
        dlg.btnCloseConnC.setDisabled(False)

        # Attempt to connect to the database
        successful_connection = conn_f.open_connection(cdbLoader)

        if successful_connection:
            # Show database name
            dlg.lblConnToDbC_out.setText(c.success_html.format(
                text=cdbLoader.DB.database_name))
            cdbLoader.DB.green_db_conn = True

            if cdbLoader.DB.pg_server_version is not None:
                # Show server version
                dlg.lblPostInstC_out.setText(c.success_html.format(
                    text=cdbLoader.DB.pg_server_version))
                cdbLoader.DB.green_post_inst=True
            else:
                dlg.lblPostInstC_out.setText(c.failure_html.format(
                    text=c.PG_SERVER_FAIL_MSG))
                cdbLoader.DB.green_post_inst=True
                return None

            # Check that database has 3DCityDB installed.
            if uc_tf.is_3dcitydb_installed(cdbLoader):
                version_major = int(cdbLoader.DB.citydb_version.split(".")[0])

                if version_major >= c.CDB_MIN_VERSION:
                    # Show 3DCityDB version
                    dlg.lbl3DCityDBInstC_out.setText(c.success_html.format(
                        text=cdbLoader.DB.citydb_version))
                    cdbLoader.DB.green_citydb_inst = True
                else:
                    dlg.lbl3DCityDBInstC_out.setText(c.crit_warning_html.format(
                        text=f"{cdbLoader.DB.citydb_version} (minimum major version: {c.CDB_MIN_VERSION})"))
                    cdbLoader.DB.green_citydb_inst = False
                    return None

            else:
                dlg.lbl3DCityDBInstC_out.setText(c.failure_html.format(
                    text=c.CDB_FAIL_MSG))
                cdbLoader.DB.green_citydb_inst = False
                return None

            # Check if main package (schema) is installed in database.
            has_main_inst = sql.is_qgis_pkg_intalled(cdbLoader)
            if has_main_inst:
                dlg.lblMainInstC_out.clear()

                # Get qgis_pkg version.
                full_version = f"(v.{sql.exec_qgis_pkg_version(cdbLoader)})"
                # Show message in Connection Status
                dlg.lblMainInstC_out.setText(c.success_html.format(text=" ".join([c.INST_MSG,full_version]).format(pkg=main_c.QGIS_PKG_SCHEMA)))
                cdbLoader.DB.green_main_inst = True
                # Enable schema comboBox
                dlg.cbxSchema.setDisabled(False)
                dlg.lblSchema.setDisabled(False)

                # Get schema name for user
                sql.exec_create_qgis_usr_schema_name(cdbLoader)

                # Get 3DCityDB schemas from database
                #schemas = sql.exec_get_feature_schemas(dbLoader)
                schemas = sql.exec_list_cdb_schemas(cdbLoader, True)

                # Fill schema combo box
                uc_tf.fill_schema_box(cdbLoader, schemas=schemas)
                # At this point,filling the schema box, activates the 'evt_cbxSchema_changed' event.
                # So if you're following the code line by line, go to citydb_loader.py>evt_cbxSchema_changed or at 'cbxSchema_setup' function below
            else:
                dlg.lblMainInstC_out.setText(c.failure_html.format(text=c.INST_FAIL_MSG).format(pkg=main_c.QGIS_PKG_SCHEMA))
                cdbLoader.DB.green_main_inst = False
                return None

        else: # Connection failed!
            ct_wf.gbxConnStatus_reset(cdbLoader)
            dlg.gbxConnStatusC.setDisabled(False)

            dlg.lblConnToDbC_out.setText(c.failure_html.format(
                text=c.CONN_FAIL_MSG))
            cdbLoader.DB.green_connection=False

            dlg.lblPostInstC_out.setText(c.failure_html.format(
                text=c.PG_SERVER_FAIL_MSG))
            cdbLoader.DB.green_pg_server_version=False

            return None
        return None


    def evt_cbxSchema_changed(self, cdbLoader: CDBLoader) -> None:
        """Event that is called when the 'schemas' comboBox (cbxSchema)
        current index changes.
        Function to setup the GUI after an 'indexChanged' signal is emitted from
        the cbxSchema combo box.
        This function runs every time the selected schema is changed.
        (in 'User Connection' tab)
        Checks if the connection + schema meet the necessary requirements.
        """
        # Set the current schema variable
        cdbLoader.CDB_SCHEMA = cdbLoader.usr_dlg.cbxSchema.currentText()

        #ct_wf.cbxSchema_setup(cdbLoader)

        # By now, the schema variable must have be assigned.
        if not cdbLoader.usr_dlg.cbxSchema.currentData():
            return None

        # Clear status of previous schema.
        cdbLoader.usr_dlg.lblUserInstC_out.clear()
        cdbLoader.usr_dlg.lblSupport_out.clear()
        cdbLoader.usr_dlg.lblLayerRefr_out.clear()

        cdbLoader.usr_dlg.btnRefreshLayers.setText(cdbLoader.usr_dlg.btnRefreshLayers.init_text.format(sch=cdbLoader.CDB_SCHEMA))
        cdbLoader.usr_dlg.btnCityExtentsC.setText(cdbLoader.usr_dlg.btnCityExtentsC.init_text.format(sch=cdbLoader.CDB_SCHEMA))
        cdbLoader.usr_dlg.btnCreateLayers.setText(cdbLoader.usr_dlg.btnCreateLayers.init_text.format(sch=cdbLoader.CDB_SCHEMA))
        cdbLoader.usr_dlg.btnDropLayers.setText(cdbLoader.usr_dlg.btnDropLayers.init_text.format(sch=cdbLoader.CDB_SCHEMA))

        # Check if user package (schema) is installed in database.
        has_user_inst = sql.is_usr_pkg_installed(cdbLoader)
        if has_user_inst:
            cdbLoader.usr_dlg.lblUserInstC_out.setText(
                c.success_html.format(text=c.INST_MSG.format(pkg=cdbLoader.USR_SCHEMA)))
            cdbLoader.DB.green_user_inst = True

            cdbLoader.usr_dlg.gbxBasemapC.setDisabled(False)
            cdbLoader.usr_dlg.cgbxOptions.setDisabled(False)        
            cdbLoader.usr_dlg.btnCreateLayers.setDisabled(False)        

            # Setup the 'Basemap (OSM)' groupbox.
            ct_wf.gbxBasemapC_setup(cdbLoader, cdbLoader.CANVAS_C)

                        # Check if there are precomputed layer extents in the database.
            mview_exts = sql.fetch_extents(
                cdbLoader,
                usr_schema=cdbLoader.USR_SCHEMA,
                cdb_schema=cdbLoader.CDB_SCHEMA,
                ext_type=c.MAT_VIEW_EXT_TYPE)
            if mview_exts:
                # Put extents coordinates into the widget. Singal emitted for qgbxExtentsC.
                cdbLoader.usr_dlg.qgbxExtentsC.setOutputExtentFromUser(QgsRectangle.fromWkt(mview_exts), cdbLoader.CRS)

        else:
            cdbLoader.usr_dlg.lblUserInstC_out.setText(c.failure_html.format(text=c.INST_FAIL_MSG.format(
                    pkg=cdbLoader.USR_SCHEMA)))
            cdbLoader.DB.green_user_inst = False
            return None

        # Check if user package has views corresponding to the current schema (layers).
        has_schema_support = sql.exec_support_for_schema(cdbLoader)
        if has_schema_support:
            cdbLoader.usr_dlg.lblSupport_out.setText(
                c.success_html.format(text=c.SCHEMA_SUPP_MSG.format(
                    sch=cdbLoader.CDB_SCHEMA)))
            cdbLoader.DB.green_schema_supp = True

            cdbLoader.usr_dlg.btnRefreshLayers.setDisabled(False)
            cdbLoader.usr_dlg.btnDropLayers.setDisabled(False)        
        else:
            cdbLoader.usr_dlg.lblSupport_out.setText(c.failure_html.format(text=c.SCHEMA_SUPP_FAIL_MSG.format(
                    sch=cdbLoader.CDB_SCHEMA)))
            cdbLoader.DB.green_schema_supp = False
            return None

        # Check if the materialised views are populated.
        refresh_date = sql.fetch_layer_metadata(cdbLoader, usr_schema=cdbLoader.USR_SCHEMA, cdb_schema=cdbLoader.CDB_SCHEMA, cols="refresh_date")
        # Extract a date.
        date = list(set(refresh_date[1]))[0][0]
        if date:
            cdbLoader.usr_dlg.lblLayerRefr_out.setText(
                c.success_html.format(text=c.REFR_LAYERS_MSG.format(date=date)))
            cdbLoader.DB.green_refresh_date = True
        else:
            cdbLoader.usr_dlg.lblLayerRefr_out.setText(c.failure_html.format(text=c.REFR_LAYERS_FAIL_MSG))
            cdbLoader.DB.green_refresh_date = False
            return None

        # Check that DB is configured correctly.
        if cdbLoader.DB.meets_requirements():
            cdbLoader.usr_dlg.tabLayers.setDisabled(False)
            cdbLoader.usr_dlg.lblInfoText.setDisabled(False)
            cdbLoader.usr_dlg.lblInfoText.setText(
                    cdbLoader.usr_dlg.lblInfoText.init_text.format(
                        db=cdbLoader.DB.database_name,
                        usr=cdbLoader.DB.username,
                        sch=cdbLoader.CDB_SCHEMA))
            cdbLoader.usr_dlg.gbxBasemap.setDisabled(False)
            cdbLoader.usr_dlg.qgbxExtents.setDisabled(False)
            cdbLoader.usr_dlg.btnCityExtents.setDisabled(False)
            cdbLoader.usr_dlg.btnCityExtents.setText(cdbLoader.usr_dlg.btnCityExtents.init_text.format(sch="layers extents"))
        
            lt_wf.gbxBasemap_setup(cdbLoader, cdbLoader.CANVAS)
            # We are done here with the 'User Connection' tab.

        # We can proceed ONLY if the necessary requirements are met.
        if cdbLoader.DB.meets_requirements():
            cdbLoader.usr_dlg.tabLayers.setDisabled(False)
        else:
            lt_wf.tabLayers_reset(cdbLoader)
            cdbLoader.usr_dlg.tabLayers.setDisabled(True)

    # 'Basemap (OSM)' group box events (in 'User Connection' tab)
    def evt_canvas_ext_changed(self, cdbLoader: CDBLoader) -> None:
        """Event that is called when the current canvas extents (pan over map)
        changes.

        Reads the new current extents from the map and sets it in the 'Extents'
        (qgbxExtentsC) widget.
        """
        # Get canvas's current extent
        extent: QgsRectangle = cdbLoader.CANVAS_C.extent()

        # Set the current extent to show in the 'extent' widget.
        cdbLoader.usr_dlg.qgbxExtentsC.setCurrentExtent(
            currentExtent=extent,
            currentCrs=cdbLoader.CRS)
        cdbLoader.usr_dlg.qgbxExtentsC.setOutputCrs(outputCrs=cdbLoader.CRS)


    def evt_qgbxExtentsC_ext_changed(self, cdbLoader: CDBLoader) -> None:
        """Event that is called when the 'Extents' groubBox (qgbxExtentsC)
        extent in widget changes.
        """
        #ct_wf.qgbxExtentsC_setup(cdbLoader)

        # Update extents variable with the ones that fired the signal.
        cdbLoader.CURRENT_EXTENTS = cdbLoader.usr_dlg.qgbxExtentsC.outputExtent()
        if cdbLoader.CURRENT_EXTENTS.isNull() or cdbLoader.CDB_SCHEMA_EXTENTS.isNull():
            return None

        # Draw the extents in the additional canvas (basemap)
        canvas.insert_rubber_band(
            band=cdbLoader.RUBBER_LAYERS_C,
            extents=cdbLoader.CURRENT_EXTENTS,
            crs=cdbLoader.CRS,
            width=2,
            color=Qt.red)

        # Compare original extents with user defined ones.
        layer_exts = QgsGeometry.fromRect(cdbLoader.CURRENT_EXTENTS)
        cdb_exts = QgsGeometry.fromRect(cdbLoader.CDB_SCHEMA_EXTENTS)

        # Check validity of user extents relative to the City Model's extents.
        #if not layer_exts.within(cdb_exts): 
        if not layer_exts.intersects(cdb_exts):
            QMessageBox.critical(
                cdbLoader.usr_dlg,
                "Warning",
                f"Pick a region inside the extents of '{cdbLoader.CDB_SCHEMA}' (blue area).")
            return None
        else:
            cdbLoader.LAYER_EXTENTS = cdbLoader.CURRENT_EXTENTS


    def evt_btnCityExtentsC_clicked(self, cdbLoader: CDBLoader) -> None:
        """Event that is called when the current 'Calculate from City model'
        pushButton (btnCityExtentsC) is pressed.
        """
        #ct_wf.btnCityExtents_setup(cdbLoader)

        # Get the extents stored in server (already computed at this point).
        extents = sql.fetch_extents(
            cdbLoader,
            usr_schema=cdbLoader.USR_SCHEMA,
            cdb_schema=cdbLoader.CDB_SCHEMA,
            ext_type=c.CDB_SCHEMA_EXT_TYPE)
        assert extents, "Extents don't exist but should have been already computed!"

        # Convert extents format to QgsRectangle object.
        extents = QgsRectangle.fromWkt(extents)
        # Update extents in plugin variable.
        cdbLoader.CURRENT_EXTENTS = extents

        # Put extents coordinates into the widget.
        cdbLoader.usr_dlg.qgbxExtentsC.setOutputExtentFromUser(cdbLoader.CURRENT_EXTENTS, cdbLoader.CRS)
        # At this point an extentChanged signal is emitted.
        
        # Zoom to these extents.
        cdbLoader.CANVAS_C.zoomToFeatureExtent(extents)


    def evt_btnCreateLayers_clicked(self, cdbLoader: CDBLoader) -> None:
        """Event that is called when the 'Create layers for schema {sch}'
        pushButton (btnCreateLayers) is pressed.
        """
        #ct_wf.btnCreateLayers_setup(cdbLoader)

        thr.create_layers_thread(cdbLoader)

        # Update the layer extents in the corresponding table in the server.
        sql.exec_upsert_extents(
            cdbLoader,
            usr_schema=cdbLoader.USR_SCHEMA,
            cdb_schema=cdbLoader.CDB_SCHEMA,
            bbox_type=c.MAT_VIEW_EXT_TYPE,
            extents=cdbLoader.LAYER_EXTENTS.asWktPolygon())

        refresh_date = []
        while not refresh_date: # Loop to allow for 'layer creation' thread to finish. Seems hacky...
            # Check if the materialised views are populated. # NOTE: Duplicate code!
            refresh_date = sql.fetch_layer_metadata(
                    cdbLoader, 
                    usr_schema=cdbLoader.USR_SCHEMA, 
                    cdb_schema=cdbLoader.CDB_SCHEMA,
                    cols="refresh_date")
            # Extract a date.
            refresh_date = list(set(refresh_date[1]))

        date = refresh_date[0][0] # Extract date.
        if date:
            cdbLoader.usr_dlg.lblLayerRefr_out.setText(
                c.success_html.format(text=c.REFR_LAYERS_MSG.format(
                    date=date)))
            cdbLoader.DB.green_refresh_date = True
        else:
            cdbLoader.usr_dlg.lblLayerRefr_out.setText(c.failure_html.format(text=c.REFR_LAYERS_FAIL_MSG))
            cdbLoader.DB.green_refresh_date = False
            return None


    def evt_btnRefreshLayers_clicked(self, cdbLoader: CDBLoader) -> None:
        """Event that is called when the 'Refresh layers for schema {sch}'
        pushButton (btnRefreshLayers) is pressed.
        """
        #ct_wf.btnRefreshLayers_setup(cdbLoader)
        res = QMessageBox.question(cdbLoader.usr_dlg, "Layer refresh", c.REFRESH_QUERY)
        if res == 16384: #YES
            thr.refresh_views_thread(cdbLoader)


    def evt_btnDropLayers_clicked(self, cdbLoader: CDBLoader) -> None:
        """Event that is called when the 'Drop layers for schema {sch}'
        pushButton (btnRefreshLayers) is pressed.
        """
        #ct_wf.btnDropLayers_setup(cdbLoader)
        thr.drop_layers_thread(cdbLoader)


    def evt_btnCloseConnC_clicked(self, cdbLoader: CDBLoader) -> None:
        """Event that is called when the 'Close current connection' pushButton
        (btnCloseConn) is pressed.
        """
        ct_wf.tabConnection_reset(cdbLoader)
        lt_wf.tabLayers_reset(cdbLoader)

    ## Events for User connection tab END

    ## Events for Layer tab BEGIN

    # 'Parameters' group box events (in 'Layers' tab)
    def evt_qgbxExtents_extChanged(self, cdbLoader: CDBLoader) -> None:
        """Event that is called when the 'Extents' groubBox (qgbxExtents)
        extent changes.
        """
        #lt_wf.qgbxExtents_setup(cdbLoader)

        # NOTE: 'Draw on Canvas'* has an undesired effect.
        # There is a hardcoded True value that causes the parent dialog to
        # toggle its visibility to let the user draw. But in our case
        # the parent dialog contains the canvas that we need to draw on.
        # Re-opening the plugin allows us to draw in the canvas but with the
        # caveat that the drawing tool never closes (also causes some QGIS crashes).
        # https://github.com/qgis/QGIS/blob/master/src/gui/qgsextentgroupbox.cpp
        # https://github.com/qgis/QGIS/blob/master/src/gui/qgsextentwidget.h
        # line 251 extentDrawn function
        # https://qgis.org/pyqgis/3.16/gui/QgsExtentGroupBox.html
        # https://qgis.org/pyqgis/3.16/gui/QgsExtentWidget.html

        # Update extents variable with the ones that fired the signal.
        cdbLoader.CURRENT_EXTENTS = cdbLoader.usr_dlg.qgbxExtents.outputExtent()

        # Draw the extents in the addtional canvas (basemap)
        canvas.insert_rubber_band(
            band=cdbLoader.RUBBER_USER,
            extents=cdbLoader.CURRENT_EXTENTS,
            crs=cdbLoader.CRS,
            width=2,
            color=Qt.green)

        # Compare original extents with user defined ones.
        qgis_exts = QgsGeometry.fromRect(cdbLoader.CURRENT_EXTENTS)
        layer_exts = QgsGeometry.fromRect(cdbLoader.LAYER_EXTENTS)

        # Check validity of user extents relative to the City Model's extents.
        if layer_exts.equals(qgis_exts) or layer_exts.contains(qgis_exts):
            cdbLoader.QGIS_EXTENTS = cdbLoader.CURRENT_EXTENTS
        else:
            QMessageBox.critical(
                cdbLoader.usr_dlg,
                "Warning",
                f"Pick a region inside the layers extents (red area).")          
            return None

        lt_wf.gbxLayerSelection_reset(cdbLoader)
        cdbLoader.usr_dlg.gbxLayerSelection.setDisabled(False)
        
        # Operations cascade to a lot of functions from here!
        # Based on the selected extents fill out the Feature Types combo box.
        l_tf.fill_FeatureType_box(cdbLoader)

        return None


    def evt_btnCityExtents_clicked(self, cdbLoader: CDBLoader) -> None:
        """Event that is called when the current 'Set to layers extents'
        pushButton (btnCityExtents) is pressed.
        """
        #lt_wf.btnCityExtents_setup(cdbLoader)
        # Get the extents stored in server (already computed at this point).
        extents = sql.fetch_extents(
            cdbLoader,
            usr_schema=cdbLoader.USR_SCHEMA,
            cdb_schema=cdbLoader.CDB_SCHEMA,
            ext_type=c.MAT_VIEW_EXT_TYPE)
        assert extents, "Extents don't exist but should have been already computed!"

        # Convert extents format to QgsRectangle object.
        extents = QgsRectangle.fromWkt(extents)
        # Update extents in plugin variable.
        cdbLoader.CURRENT_EXTENTS = extents
        cdbLoader.QGIS_EXTENTS = extents

        # Put extents coordinates into the widget.
        cdbLoader.usr_dlg.qgbxExtents.setOutputExtentFromUser(cdbLoader.CURRENT_EXTENTS, cdbLoader.CRS)
        # At this point an extentChanged signal is emitted.

        # Zoom to these extents.
        cdbLoader.CANVAS.zoomToFeatureExtent(extents)


    def evt_cbxFeatureType_changed(self, cdbLoader: CDBLoader) -> None:
        """Event that is called when the 'Feature Type'comboBox (cbxFeatureType)
        current index changes.
        """
        #lt_wf.cbxFeatureType_setup(cdbLoader)
        
        # Clear 'Geometry Level' combo box from previous runs.
        cdbLoader.usr_dlg.cbxLod.clear()
        # Enable 'Geometry Level' combo box
        cdbLoader.usr_dlg.cbxLod.setDisabled(False)

        # Fill out the LoDs, based on the selected extents and Feature Type.
        l_tf.fill_lod_box(cdbLoader)


    def evt_cbxLod_changed(self, cdbLoader: CDBLoader) -> None:
        """Event that is called when the 'Geometry Level'comboBox (cbxLod)
        current index changes.
        """
        #lt_wf.cbxLod_setup(cdbLoader)

        # Enable 'Features to Import' group box.
        cdbLoader.usr_dlg.gbxAvailableL.setDisabled(False)

        # Clear 'Features' checkable combo box from previous runs.
        cdbLoader.usr_dlg.ccbxFeatures.clear()
        # Revert to initial text.
        cdbLoader.usr_dlg.ccbxFeatures.setDefaultText(cdbLoader.usr_dlg.ccbxFeatures.init_text)

        # Fill out the features.
        l_tf.fill_features_box(cdbLoader)


    # 'Features to Import' group box events (in 'Layers' tab)
    def evt_cbxFeatures_changed(self, cdbLoader: CDBLoader) -> None:
        """Event that is called when the 'Available Features'
        checkableComboBox (ccbxFeatures) current index changes.
        """
        #lt_wf.ccbxFeatures_setup(cdbLoader)

        # Get all the selected layers (views).
        checked_views = cdbLoader.usr_dlg.ccbxFeatures.checkedItems()

        if checked_views:
            # Enable 'Import' pushbutton.
            cdbLoader.usr_dlg.btnImport.setDisabled(False)
        else:
            # Revert to initial text and disable 'Import' pushbutton
            cdbLoader.usr_dlg.btnImport.setDisabled(True)


    def evt_btnImport_clicked(self, cdbLoader: CDBLoader) -> None:
        """Event that is called when the 'Import Features' pushButton
        (btnImport) is pressed.
        """
        #lt_wf.btnImport_setup(cdbLoader)

        # Get the data that is checked from 'ccbxFeatures'
        # Remember widget hold items in the form of (view_name, View_object)
        checked_views = l_tf.get_checkedItemsData(cdbLoader.usr_dlg.ccbxFeatures)
        #checked_views = cdbLoader.usr_dlg.ccbxFeatures.checkedItemsData() NOTE: this built-in method works only for string types. Check https://qgis.org/api/qgscheckablecombobox_8cpp_source.html line 173

        # Get the total number of features to be imported.
        counter = 0
        for view in checked_views:
            counter += view.n_selected

        # Warn user when too many features are to be imported. (Subjective value).

        if counter>c.MAX_FEATURES_PER_LAYER:
            res = QMessageBox.question(
                cdbLoader.usr_dlg,
                "Warning",
                f"Too many features ({counter}) within the selected area!\n"
                "This could reduce QGIS performance and may lead to crashes.\n"
                "Do you want to continue anyway?")
            if res == 16384: # YES
                success = l_tf.import_layers(cdbLoader, layers=checked_views)
            else:
                return None #Import Cancelled
        else:
            success = l_tf.import_layers(cdbLoader, layers=checked_views)

        if not success:
            QgsMessageLog.logMessage(
                message="Something went wrong while importing the layer(s)!",
                tag=main_c.PLUGIN_NAME,
                level=Qgis.Critical,
                notifyUser=True)
            return None


        # Structure 'Table of Contents' tree.
        db_group = l_tf.get_node_database(cdbLoader)
        l_tf.sort_ToC(db_group)
        l_tf.send_to_top_ToC(db_group)

        #At last bring the Relief, Feature type at the bottom of the ToC.
        l_tf.send_to_bottom_ToC(QgsProject.instance().layerTreeRoot())

        #Set CRS of the project to match the one of the 3DCityDB.
        QgsProject.instance().setCrs(cdbLoader.CRS)
        
        # A final success message.
        QgsMessageLog.logMessage(
                message="",
                tag=main_c.PLUGIN_NAME,
                level=Qgis.Success,
                notifyUser=True)
        return None

        # Here is the final step.
        # Meaning that user did everything and can now close
        # the window to continue working outside the plugin.


#NOTE: extent groupbox doesn't work for manual user input
#for every value change in any of the 4 inputs the extent signal is emitted

    ## Events for Layer tab END

    ### EVENTS (end) ############################