"""
/***************************************************************************
 Class CDB4AdminDialog

        This is a QGIS plugin for the CityGML 3D City Database.
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                             -------------------
        begin                : 2021-09-30
        git sha              : $Format:%H$
        author(s)            : Giorgio Agugiaro
                               Konstantinos Pantelios
        email                : g.agugiaro@tudelft.nl
                               konstantinospantelios@yahoo.com
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""
import os
# from psycopg2.extensions import connection as pyconn

from qgis.core import Qgis, QgsMessageLog
from qgis.gui import QgsMessageBar

from qgis.PyQt import uic, QtWidgets
from qgis.PyQt.QtCore import Qt
from qgis.PyQt.QtWidgets import QMessageBox

from ...cdb_tools_main import CDBToolsMain # Used only to add the type of the function parameters

from ..gui_db_connector.other_classes import Connection
from ..gui_db_connector.db_connector_dialog import DBConnectorDialog
from ..gui_db_connector.functions import conn_functions as conn_f
from ..shared.functions import sql as sh_sql 
from ..shared.functions import general_functions as gen_f  

from .other_classes import AdminDefaultSettings, FeatureType, AdminDialogChecks
from .functions import sql
from .functions import tab_install_widget_functions as ti_wf
from .functions import tab_settings_widget_functions as ts_wf
from .functions import threads as thr

from . import admin_constants as c

# This loads the .ui file so that PyQt can populate the plugin with the elements from Qt Designer
FORM_CLASS, _ = uic.loadUiType(os.path.join(os.path.dirname(__file__), "ui", "cdb4_admin_dialog.ui"))

class CDB4AdminDialog(QtWidgets.QDialog, FORM_CLASS):
    """Administrator Dialog class of the plugin. The GUI is imported from an external .ui xml
    """

    def __init__(self, cdbMain: CDBToolsMain, parent=None):
        """Constructor."""
        super(CDB4AdminDialog, self).__init__(parent)
        # Set up the user interface from Designer through FORM_CLASS.
        # After self.setupUi() you can access any designer object by doing
        # self.<objectname>, and you can use autoconnect slots

        self.setupUi(self)

        ############################################################
        ## From here you can add your variables or constants
        ############################################################

        self.DIALOG_NAME: str = cdbMain.PLUGIN_NAME_ADMIN

        # # Variable to store the current open connection of a database.
        # self.conn: pyconn = None
        # # Variable to store the existing connection parameters.
        # self.DB: Connection = None

        # Initialize classes containing requirements, settings, etc.
        self.settings = AdminDefaultSettings()
        self.checks = AdminDialogChecks()

        # Variable to store metadata about the Feature Types (i.e. CityGML modules/packages) 
        self.FeatureTypesRegistry: dict = {
            "Bridge"        : FeatureType(alias='bridge'        ),
            "Building"      : FeatureType(alias='building'      ),
            "CityFurniture" : FeatureType(alias='cityfurniture' ),
            "Generics"      : FeatureType(alias='generics'      ),
            "LandUse"       : FeatureType(alias='landuse'       ),
            "Relief"        : FeatureType(alias='relief'        ),
            "Transportation": FeatureType(alias='transportation'),
            "Tunnel"        : FeatureType(alias='tunnel'        ),
            "Vegetation"    : FeatureType(alias='vegetation'    ),
            "WaterBody"     : FeatureType(alias='waterbody'     )
            }

        # Initialize label values. This is used in order to revert to the original state 
        # in reset operations when original text has already changed.

        # Connection button labels
        self.btnConnectToDb.init_text = c.btnConnectToDbC_t
        
        # Main installation button labels
        self.btnMainInst.init_text = c.btnMainInst_t
        self.btnMainUninst.init_text=  c.btnMainUninst_t
        
        # User installation button labels
        # self.btnUsrInst.init_text = c.btnUsrInst_t
        # self.btnUsrUninst.init_text = c.btnUsrUninst_t

        #- SIGNALS  (start)  ################################################################

        #### 'Admin Connection' tab

        # 'Connection' group box signals
        self.cbxExistingConn.currentIndexChanged.connect(lambda: self.evt_cbxExistingConn_changed(cdbMain))
        self.btnNewConn.clicked.connect(lambda: self.evt_btnNewConn_clicked(cdbMain))
        self.btnConnectToDb.clicked.connect(lambda: self.evt_btnConnectToDb_clicked(cdbMain))

        # 'Main Installation' group box signals
        self.btnMainInst.clicked.connect(lambda: self.evt_btnMainInst_clicked(cdbMain))
        self.btnMainUninst.clicked.connect(lambda: self.evt_btnMainUninst_clicked(cdbMain))

        # 'User Installation' group box signals
        self.btnAddUserToGrp.clicked.connect(lambda: self.evt_btnAddUserToGrp_clicked(cdbMain))

        self.cbxUser.currentIndexChanged.connect(lambda: self.evt_cbxPluginUser_changed(cdbMain))
        self.btnRemoveUserFromGrp.clicked.connect(lambda: self.evt_btnRemoveUserFromGrp_clicked(cdbMain))
        self.btnUsrInst.clicked.connect(lambda: self.evt_btnUsrInst_clicked(cdbMain))
        self.btnUsrUninst.clicked.connect(lambda: self.evt_btnUsrUninst_clicked(cdbMain))

        self.ckbUserRO.toggled.connect(self.evt_ckbUserRO_toggled)
        self.btnSetPriv.clicked.connect(lambda: self.evt_btnSetPriv_clicked(cdbMain))

        # Close connection button
        self.btnCloseConn.clicked.connect(lambda: self.evt_btnCloseConn_clicked(cdbMain))

        #### 'Installation Settings' tab
        self.ckbSelAllCDBSch.toggled.connect(self.evt_ckbSelAllCDBSch_toggled)
        self.ckbUserRW.toggled.connect(self.evt_ckbUserRW_toggled)

        self.btnResetToDefault.clicked.connect(lambda: self.evt_btnResetToDefault_clicked(cdbMain))

        #-SIGNALS  (end)  ################################################################

    # EVENT FUNCTIONS (begin)  #####################################################################

    #### Events for 'connection' TAB

    # 'Connection' group box events
    def evt_cbxExistingConn_changed(self, cdbMain: CDBToolsMain) -> None:
        """Event that is called when the 'Existing Connection' comboBox (cbxExistingConn) current index changes.
        This function runs every time the current selection of 'Existing Connection' changes.
        """
        # Close the (previous?) open connection.
        if cdbMain.conn:
            cdbMain.conn.close()

        # Set the current database connection object variable
        cdbMain.DB: Connection = self.cbxExistingConn.currentData()

        # Check that the connection parameters were set
        if not cdbMain.DB:
            return None # Exit

        # Reset the Database Administration tab from previous runs
        # All tabs are also disabled first.
        ti_wf.tabInstall_reset(cdbMain)
        ts_wf.tabSettings_reset(cdbMain)

        # Enable Install tab.
        self.tabInstall.setDisabled(False)

        # Enable button to connect.
        self.btnConnectToDb.setText(self.btnConnectToDb.init_text.format(db=cdbMain.DB.database_name))
        self.btnConnectToDb.setDisabled(False)

    
    def evt_btnNewConn_clicked(self, cdbMain: CDBToolsMain) -> None:
        """Event that is called when the 'New Connection' pushButton (btnNewConn) is pressed.
        Responsible to add VALID new connection to the 'Existing connections'.
        """
        # Bypass the input blockade for the connector dialogue.
        self.setWindowModality(Qt.WindowModal)

        # Create/Show/Execute additional dialog for the new connection
        dlgConnector = DBConnectorDialog()
        dlgConnector.setWindowModality(Qt.ApplicationModal)
        dlgConnector.show()
        dlgConnector.exec_()

        # Add new connection to the Existing connections
        if dlgConnector.conn_params:
            self.cbxExistingConn.addItem(f"{dlgConnector.conn_params.connection_name}", dlgConnector.conn_params)
            # dlgConnector.close()

        # Re-set the input blockage
        self.setWindowModality(Qt.ApplicationModal)


    def evt_btnConnectToDb_clicked(self, cdbMain: CDBToolsMain) -> None:
        """Event that is called when the current 'Connect to {db}' pushButton (btnConnectToDb) is pressed.
        """
        # Variable to store the plugin main dialog.
        db = cdbMain.DB

        msg: str = None

        # Enable 'Connection Status' group box.
        self.gbxConnStatus.setDisabled(False)

        # -------------------------------------------------------------------------------------------
        # Series of tests to be carried out when I connect as admin.
        #
        # 1) Can I connect to the database?
        #        if yes: Is the PostgreSQL version >= 10? 
        #           If yes, continue
        #           if no, exit
        #        If yes: is the user a superuser?
        #            if yes, continue
        #            if no, exit
        #        if no, exit
        # 2) Is the 3DCityDB installed? 
        #       If yes, is it v. 4?
        #           If yes, continue
        #           iF no, exit
        #       If no, exit
        # 3) Is the QGIS Package already installed?
        #       if yes: Is it a compatible version?
        #                if yes, continue
        #                if no, inform the user that an upgrade is required
        #       if no: continue and offer to install
        # -------------------------------------------------------------------------------------------

        # 1) Can I connect to the database?

        # Attempt to connect to the database, returns True/False, and if successful, store connection in cdbMain.conn
        # Additionally, set cdbMain.DB.pg_server_version
        is_connection_successful: bool = conn_f.open_connection(cdbMain, cdbMain.PLUGIN_NAME_ADMIN)

        if is_connection_successful:
            # Set/update the status check variable
            self.checks.is_conn_successful = True

            # Show database name in the Connection Status
            self.lblConnToDb_out.setText(c.success_html.format(text=db.database_name))

            # Enable 'Close current connection' button.
            self.btnCloseConn.setDisabled(False)
            
            # Get the PosgreSQL version (i.e. v. 10.0)
            postgres_major_version: int = int(db.pg_server_version.split(".")[0])

            #######################################
            # Only for debugging purposes
            # postgres_major_version: int = 9
            #######################################

            if postgres_major_version >= c.PG_MIN_VERSION:
                # Show PostgreSQL version in green and continue (all fine)
                self.lblPostInst_out.setText(c.success_html.format(text=db.pg_server_version))
            else:
                # Show database name we are connected to
                self.lblConnToDb_out.setText(c.success_html.format(text=db.database_name))
                # Show unsupported version of PostgreSQL
                self.lblPostInst_out.setText(c.failure_html.format(text=c.PG_VERSION_UNSUPPORTED_MSG))

                # Inform the user
                msg = f"You are connecting to PostgreSQL version {db.pg_server_version}. This version is not supported, you need version {c.PG_MIN_VERSION} or higher."
                QMessageBox.critical(self, "Unsupported PostgreSQL version", msg)

                ti_wf.tabInstall_reset(cdbMain)
                ts_wf.tabSettings_reset(cdbMain)
                if cdbMain.conn:
                    cdbMain.conn.close()

                return None # Exit

            # Check whether the user is an admin.
            is_superuser: bool = sql.is_superuser(cdbMain)

            if is_superuser:
                # Update the label in the Connection status
                self.lblUserPrivileges_out.setText(c.success_html.format(text=c.USER_PRIV_MSG.format(privs=' superuser')))
            else:
                # Update the label in the Connection status
                self.lblUserPrivileges_out.setText(c.failure_html.format(text=c.USER_PRIV_MSG.format(privs='no superuser')))

                # Inform the user
                msg = f"User '{db.username}' is not a database superuser. Please contact your database administrator."
                QMessageBox.critical(self, "Insufficient user privileges", msg)

                ti_wf.tabInstall_reset(cdbMain)
                ts_wf.tabSettings_reset(cdbMain)
                if cdbMain.conn:
                    cdbMain.conn.close()

                return None # Exit

        else: # Connection failed!
            # Set/update the status check variable
            self.checks.is_conn_successful = False
            
            # Update the message in the Connection Status
            self.lblConnToDb_out.setText(c.failure_html.format(text=c.CONN_FAIL_MSG))

            # Inform the user
            error_msg = f"The selected connection to the PostgreSQL server cannot be established. Please check whether it is still valid: the connection parameters may have to be updated!"
            QMessageBox.warning(self, "Connection error", error_msg)

            ti_wf.tabInstall_reset(cdbMain)
            ts_wf.tabSettings_reset(cdbMain)
            if cdbMain.conn:
                cdbMain.conn.close()

            return None # Exit

        # 2) Is the 3DCityDB installed? 

        # Check that database has 3DCityDB installed.
        is_3dcitydb_installed: bool = sql.is_3dcitydb_installed(cdbMain)

        ###########################################
        # Only for debugging purposes
        # is_3dcitydb_installed = False
        ###########################################

        if is_3dcitydb_installed:
            # Set/update the status check variable
            self.checks.is_3dcitydb_installed = True

            citydb_version_major: int = int(db.citydb_version.split(".")[0])

            #####################################
            # Only for debugging purposes
            # citydb_version_major: int = 3
            #####################################

            if citydb_version_major == c.CDB_MIN_VERSION:
                # Set/update the status check variable
                self.checks.is_3dcitydb_supported = True

                # Show 3DCityDB version
                self.lbl3DCityDBInst_out.setText(c.success_html.format(text=db.citydb_version))
            else:
                # Set/update the status check variable
                self.checks.is_3dcitydb_supported = False

                # Set the label in the Connection Groupbox (Missing citydb installation)
                self.lbl3DCityDBInst_out.setText(c.crit_warning_html.format(text=f"{db.citydb_version} (required v. {c.CDB_MIN_VERSION}.x)"))

                msg = f"The 3D City Database installed in this database is v. {db.citydb_version} and it is not supported. You need 3D City Database v. {c.CDB_MIN_VERSION}.x."
                QMessageBox.critical(self, "Unsupported 3D City Database version", msg)

                ti_wf.tabInstall_reset(cdbMain)
                ts_wf.tabSettings_reset(cdbMain)
                if cdbMain.conn:
                    cdbMain.conn.close()

                return None
        else:
            # Set/update the status check variable
            self.checks.is_3dcitydb_installed = False

            # Set the label in the Connection Groupbox (Missing citydb installation)
            self.lbl3DCityDBInst_out.setText(c.failure_html.format(text=c.CDB_FAIL_MSG))

            # Inform the user
            msg = f"The 3D City Database is not installed in this database."
            QMessageBox.critical(self, "No 3DCityDB found", msg)

            ti_wf.tabInstall_reset(cdbMain)
            ts_wf.tabSettings_reset(cdbMain)
            if cdbMain.conn:
                cdbMain.conn.close()

            return None # Exit

        # From here on, no need to exit the function anymore with return None.

        # 3) Is the QGIS Package already installed?

        # Fill out the labels of the buttons, no matter what.
        self.btnMainInst.setText(self.btnMainInst.init_text.format(db=db.database_name))
        self.btnMainUninst.setText(self.btnMainUninst.init_text.format(db=db.database_name))

        # Enable 'Main installation' group box.
        self.gbxMainInst.setDisabled(False)

        # Check if the qgis_pkg schema (main installation) is installed in database.
        is_qgis_pkg_installed: bool = sh_sql.is_qgis_pkg_installed(cdbMain)

        ##########################################
        # Only for debugging purposes
        # is_qgis_pkg_installed: bool = False
        ##########################################

        if is_qgis_pkg_installed:
            # Set/update the status check variable
            self.checks.is_qgis_pkg_installed = True
           
            # Get the current qgis_pkg version and check that it is compatible.
            qgis_pkg_curr_version: tuple = sh_sql.exec_qgis_pkg_version(cdbMain)

            # Named tuple: full_version, major_version, minor_version, minor_revision, code_name, release_date

            qgis_pkg_curr_version_txt      : str = qgis_pkg_curr_version.version         # e.g. 0.9.1
            qgis_pkg_curr_version_major    : int = qgis_pkg_curr_version.major_version   # e.g. 0
            qgis_pkg_curr_version_minor    : int = qgis_pkg_curr_version.minor_version   # e.g. 9
            qgis_pkg_curr_version_minor_rev: int = qgis_pkg_curr_version.minor_revision  # e.g. 1

            # qgis_pkg_curr_version_txt      : str = qgis_pkg_curr_version[0]
            # qgis_pkg_curr_version_major    : int = qgis_pkg_curr_version[2]
            # qgis_pkg_curr_version_minor    : int = qgis_pkg_curr_version[3]
            # qgis_pkg_curr_version_minor_rev: int = qgis_pkg_curr_version[4]

            ###########################################################
            # Only for testing purposes
            # qgis_pkg_curr_version_txt      : str = "0.7.3"
            # qgis_pkg_curr_version_major    : int = 0
            # qgis_pkg_curr_version_minor    : int = 7
            # qgis_pkg_curr_version_minor_rev: int = 3
            ###########################################################

            # Check that the QGIS Package version is >= than the minimum required for this versin of the plugin (see cdb4_constants.py)
            if all((qgis_pkg_curr_version_major == c.QGIS_PKG_MIN_VERSION_MAJOR,
                    qgis_pkg_curr_version_minor == c.QGIS_PKG_MIN_VERSION_MINOR,
                    qgis_pkg_curr_version_minor_rev >= c.QGIS_PKG_MIN_VERSION_MINOR_REV)):

                # Set/update the status check variable
                self.checks.is_qgis_pkg_supported = True

                # Show message in Connection Status the Qgis Package is installed (and version)
                self.lblMainInst_out.setText(c.success_html.format(text=c.INST_SUCC_MSG + " (v. " + qgis_pkg_curr_version_txt + ")").format(pkg=cdbMain.QGIS_PKG_SCHEMA))

                # Get and assign the variable with the group name
                # group name (qgis_pkg_usrgroup_*) assigned to cdbMain.GROUP_NAME
                sql.exec_create_qgis_pkg_usrgroup_name(cdbMain)
                # print('cdbMain.GROUP_NAME:', cdbMain.GROUP_NAME)

                # Set the current user schema name for the current db admin user (e.g. postgres)
                # cdbMain.USR_SCHEMA is now set.
                sh_sql.exec_create_qgis_usr_schema_name(cdbMain)
                # print('cdbMain.USR_SCHEMA:', cdbMain.USR_SCHEMA)

                # Finish setting up the GUI
                ti_wf.setup_post_qgis_pkg_installation(cdbMain)

            else: # Wrong (outdated?) version of QGIS Package
                # Set/update the status check variable
                self.checks.is_qgis_pkg_supported = False

                # Update the Connection Status label 
                self.lblMainInst_out.setText(c.warning_html.format(text=c.INST_FAIL_VERSION_MSG))
                # Dectivate the install button
                self.btnMainInst.setDisabled(True)
                # Activate the uninstall button
                self.btnMainUninst.setDisabled(False)

                # Inform the user
                msg = f"The QGIS Package (v. {qgis_pkg_curr_version_txt}) installed in this database is not supported. Please uninstall it and replace it with the one (v. {c.QGIS_PKG_MIN_VERSION_TXT}) provided herewith."
                QMessageBox.warning(self, "Unsupported QGIS Package version", msg)
                # QgsMessageLog.logMessage(msg, cdbMain.PLUGIN_NAME, level=Qgis.Warning)

        else:  # QGIS Package is not installed
            # Set/update the status check variable
            self.checks.is_qgis_pkg_installed = False

            # Update the label in the Connection status box (QGIS Package is not installed)
            self.lblMainInst_out.setText(c.crit_warning_html.format(text=c.INST_FAIL_MSG.format(pkg=cdbMain.QGIS_PKG_SCHEMA)))

            # Fisish setting up the GUI
            ti_wf.setup_post_qgis_pkg_uninstallation(cdbMain)

            
    def evt_btnMainInst_clicked(self, cdbMain: CDBToolsMain) -> None:
        """Event that is called when the 'Install to database' pushButton (btnMainInst) is pressed.
        """
        msg = f"Any previous installation of '{cdbMain.QGIS_PKG_SCHEMA}' will be replaced! Do you want to proceed?"
        res = QMessageBox.question(self, "Installation", msg)
        if res == 16384: #YES
            thr.run_install_qgis_pkg_thread(cdbMain, sql_scripts_path=c.PG_SCRIPTS_INST_PATH, qgis_pkg_schema=cdbMain.QGIS_PKG_SCHEMA)

        return None


    def evt_btnMainUninst_clicked(self, cdbMain: CDBToolsMain) -> None:
        """Event that is called when the 'Uninstall from database' pushButton (btnMainUninst) is pressed.
        """
        msg = f"Uninstalling '{cdbMain.QGIS_PKG_SCHEMA}'! Do you want to proceed?"
        res = QMessageBox.question(self, "Uninstallation", msg)
        if res == 16384: #YES
            thr.run_uninstall_qgis_pkg_thread(cdbMain)

        return None


    def evt_btnAddUserToGrp_clicked(self, cdbMain: CDBToolsMain) -> None:
        """ Event that is called when the button 'Add to qgis_user_group' is pressed (btnAddUserToGrp).
        """
        usr_name = self.cbxSelUser4Grp.currentText()
        index = self.cbxSelUser4Grp.currentIndex()
        sql.exec_add_user_to_qgis_pkg_usrgroup(cdbMain, usr_name)

        # Remove the entry from the combox
        self.cbxSelUser4Grp.removeItem(index)

        if self.cbxSelUser4Grp.count() == 0:
            ti_wf.fill_database_users_box(cdbMain, None) 
            self.cbxSelUser4Grp.setDisabled(True)
            self.btnAddUserToGrp.setDisabled(True)

        # Update the list of the users that are part of the group in the Installation tab
        usr_names = sql.exec_list_qgis_pkg_usrgroup_members(cdbMain)

        # Refill the combobox of the plugin users
        ti_wf.fill_plugin_users_box(cdbMain, usr_names)

        # Inform user
        msg = f"User '{usr_name}' has been succesfully added to the database group '{cdbMain.GROUP_NAME}'"
        QgsMessageLog.logMessage(msg, cdbMain.PLUGIN_NAME, level=Qgis.Info)

        return None


    def evt_cbxPluginUser_changed(self, cdbMain: CDBToolsMain) -> None:
        """Event that is called when the 'Selected User' comboBox (cbxUser) current index changes.
        """
        # Retrieve current user from combobox
        usr_name: str = self.cbxUser.currentText()
        # print("current usr_name", usr_name)

        if not usr_name or usr_name == "None available":
            # Disable the Create usr_schema button
            self.btnUsrInst.setDisabled(True)
            # Disable the Drop usr_schema button
            self.btnUsrUninst.setDisabled(True)
            # Clean the label of the user scheama installation.
            self.lblUserInst_out.setText(None)

            return None # Exit, as there is nothing to do.
        
        # Create the corresponding usr_schema, add the usr_name to the group (if it is not yet member), 
        # set it to the cdbMain.USR_SCHEMA
        sh_sql.exec_create_qgis_usr_schema_name(cdbMain, usr_name=usr_name)
    
        # Set the labels of the buttons
        # self.btnUsrInst.setText(self.btnUsrInst.init_text.format(usr=usr_name))
        # self.btnUsrUninst.setText(self.btnUsrUninst.init_text.format(usr=usr_name))
        
        # Check if usr_schema is already installed in the database.
        is_usr_pkg_installed: bool = sh_sql.is_usr_schema_installed(cdbMain)

        if is_usr_pkg_installed:
            # Update the lable in the connection status box
            self.lblUserInst_out.setText(c.success_html.format(text=c.INST_SUCC_MSG.format(pkg=cdbMain.USR_SCHEMA)))

            # Disable the remove from group button
            self.btnRemoveUserFromGrp.setDisabled(True)
            # Disable the Create usr_schema button
            self.btnUsrInst.setDisabled(True)
            # Enable the Drop usr_schema button
            self.btnUsrUninst.setDisabled(False)

            # 3) User privileges settings

            # Enable privileges groupbox
            self.gbxPriv.setDisabled(False)

            # Retrieve the list of cdb_schemas with their privileges status
            # cdb_schemas_with_priv = sql.exec_list_cdb_schemas_with_privileges(cdbMain, usr_name)
            
            # Retrieve the list of cdb_schemas with their privileges status
            # Function returns a list of named tuples (cdb_schema, co_number, priv_type)
            cdb_schemas = sql.exec_list_cdb_schemas_extended(cdbMain, usr_name)
            # Fill the combobox of the cdb_schemas in the groupbox
            ti_wf.fill_cdb_schemas_box(cdbMain, cdb_schemas)

        else:
            # Update the label in the connection status box
            self.lblUserInst_out.setText(c.crit_warning_html.format(text=c.INST_FAIL_MSG.format(pkg=cdbMain.USR_SCHEMA)))
 
            # Enable the remove from group button
            self.btnRemoveUserFromGrp.setDisabled(False)
            # Enable the create usr_schema button
            self.btnUsrInst.setDisabled(False)
            # Disable the create usr_schema button
            self.btnUsrUninst.setDisabled(True)

            # Reset and disable the user privileges groupbox
            ti_wf.gbxPriv_reset(cdbMain) # this also disables it.


    def evt_btnRemoveUserFromGrp_clicked(self, cdbMain: CDBToolsMain) -> None:
        """ Event that is called when the button 'Remove from group' is pressed (btnRemoveUserFromGrp).
        """
        usr_name = self.cbxUser.currentText()
        index = self.cbxUser.currentIndex()

        # Remove user from the group in the database.
        sql.exec_remove_user_from_qgis_pkg_usrgroup(cdbMain, usr_name)

        # Remove the entry from the combox and update the current combobox
        # It automatically fires the event self.evt_cbxPluginUser_changed())
        self.cbxUser.removeItem(index)

        # Update the current in case 
        if self.cbxUser.count() == 0:
            # Update the plugin users combobox
            ti_wf.fill_plugin_users_box(cdbMain, None) # this also disables it

            # Disable the remove from group button
            self.btnRemoveUserFromGrp.setDisabled(True)
            # Disable the User schema Install button
            self.btnUsrInst.setDisabled(True)
            # Disable the User schema Uninstall button
            self.btnUsrUninst.setDisabled(True)
            # Reset and disable the user privileges groupbox
            ti_wf.gbxPriv_reset(cdbMain) # this also disables it.

        # Update the combobox with the database usr_names

        # Update the list of the users that are part of the group in the Installation tab
        db_usr_names = sql.exec_list_qgis_pkg_non_usrgroup_members(cdbMain)
        # Refill the combobox of the plugin users
        ti_wf.fill_database_users_box(cdbMain, db_usr_names)

        # Inform user
        msg = f"User '{usr_name}' has been succesfully removed from group '{cdbMain.GROUP_NAME}'"
        QgsMessageLog.logMessage(msg, cdbMain.PLUGIN_NAME, level=Qgis.Info)
        # QMessageBox.information(self, "User added!", msg)

        return None


    def evt_btnUsrInst_clicked(self, cdbMain: CDBToolsMain) -> None:
        """Event that is called when the 'Create schema for user' pushButton (btnUsrInst) is pressed.
        """
        msg = f"Any previous installation of '{cdbMain.USR_SCHEMA}' will be replaced! Do you want to proceed?"
        res = QMessageBox.question(self, "Installation", msg)
        if res == 16384: #YES
            sql.exec_create_qgis_usr_schema(cdbMain)
        if not res: # Query was canceled by user, or error occurred.
            return None

        # Create QgsMessageBar instance.
        self.msg_bar = QgsMessageBar()
        # Add the message bar into the input layer and position.
        self.vLayoutUserInstGroup.insertWidget(2, self.msg_bar)
        
        if sh_sql.is_usr_schema_installed(cdbMain):

            # Retrieve current user from combobox
            usr_name: str = self.cbxUser.currentText()
            # print("current usr_name", usr_name)

            # Disable the remove from group button
            self.btnRemoveUserFromGrp.setDisabled(True)
            # Disable the create usr_schema button
            self.btnUsrInst.setDisabled(True)
            # Enable the drop usr_schema button
            self.btnUsrUninst.setDisabled(False)

            # Enable the User Privileges Group
            self.gbxPriv.setDisabled(False)

            # Retrieve the list of cdb_schemas with their privileges status
            # Function returns a list of named tuples (cdb_schema, co_number, priv_type)
            cdb_schemas  = sql.exec_list_cdb_schemas_extended(cdbMain, usr_name)
            # Fill the combobox of the cdb_schemas in the groupbox
            ti_wf.fill_cdb_schemas_box(cdbMain, cdb_schemas)

            # Replace with Success msg.
            msg = self.msg_bar.createMessage(c.INST_SUCC_MSG.format(pkg=cdbMain.USR_SCHEMA))
            self.msg_bar.pushWidget(msg, Qgis.Success, 5)

            # Inform user
            self.lblUserInst_out.setText(c.success_html.format(text=c.INST_SUCC_MSG.format(pkg=cdbMain.USR_SCHEMA)))
            QgsMessageLog.logMessage(
                    message=c.INST_SUCC_MSG.format(pkg=cdbMain.USR_SCHEMA),
                    tag=cdbMain.PLUGIN_NAME,
                    level=Qgis.Success,
                    notifyUser=True)
        else:
            # Enable the remove from group button
            self.btnRemoveUserFromGrp.setDisabled(False)
            # Enable the create usr_schema button
            self.btnUsrInst.setDisabled(False)
            # Disable the create usr_schema button
            self.btnUsrUninst.setDisabled(True)

            # Reset and disable the user privileges groupbox
            ti_wf.gbxPriv_reset(cdbMain) # this also disables it.

            # Replace with Failure msg.
            msg = self.msg_bar.createMessage(c.INST_FAIL_MSG.format(pkg=cdbMain.USR_SCHEMA))
            self.msg_bar.pushWidget(msg, Qgis.Critical, 5)

            # Inform user
            self.lblUserInst_out.setText(c.crit_warning_html.format(text=c.INST_FAIL_MSG.format(pkg=cdbMain.USR_SCHEMA)))
            QgsMessageLog.logMessage(
                    message=c.INST_FAIL_MSG.format(pkg=cdbMain.USR_SCHEMA),
                    tag=cdbMain.PLUGIN_NAME,
                    level=Qgis.Critical,
                    notifyUser=True)


    def evt_btnUsrUninst_clicked(self, cdbMain: CDBToolsMain) -> None:
        """Event that is called when the 'Drop schema for user' pushButton
        (btnUsrUninst) is pressed.
        """
        msg = f"Uninstalling user schema '{cdbMain.USR_SCHEMA}'!\nDo you want to proceed?"
        res = QMessageBox.question(self, "Uninstallation", msg)
        if res == 16384: #YES
            # Run scripts
            thr.run_drop_usr_schema_thread(cdbMain)
        else: # Query was cancelled by user, or error occurred.
            return None


    def evt_ckbSelAllCDBSch_toggled(self) -> None:
        """ Toggles the status of the ALL selection checkbox. 
        If checked, it will turn all entries to checked.
        If unchecked, it will set all entries to unchecked.
        """
        status: bool = self.ckbSelAllCDBSch.isChecked()

        if status: # Selected/Checked
            # Select all items in combobox with cdb_schemas, set status to 2 (Checked)
            for i in range(self.ccbSelCDBSch.count()):
                 self.ccbSelCDBSch.setItemCheckState(i, Qt.Checked)
            # Disable the drop down menu
            self.ccbSelCDBSch.setDisabled(True)
        else:
            # Unselect all items in combobox with cdb_schemas, set status to 0 (Unchecked)
            for i in range(self.ccbSelCDBSch.count()):
                 self.ccbSelCDBSch.setItemCheckState(i, Qt.Unchecked)
            # Enable the drop down menu
            self.ccbSelCDBSch.setDisabled(False)
            
        return None


    def evt_btnSetPriv_clicked(self, cdbMain: CDBToolsMain) -> None:
        """ Event that is called when the button 'Set (privileges)' is pressed (btnSetPriv).
        """
        # Get the selected plugin user
        sel_usr_name: str = self.cbxUser.currentText()
        # print ("Selected user:", sel_usr_name)
        if not sel_usr_name:
            return None # Exit, something went wrong

        # Store all available cdb_schemas, regardless of the selection
        # At least the default citydb should exist.
        all_cdb_schemas: list = []
        for i in range(0, self.ccbSelCDBSch.count()):
            all_cdb_schemas.append(self.ccbSelCDBSch.itemData(i))
        # print("all_cdb_schemas:", all_cdb_schemas)

        if self.ckbSelAllCDBSch.isChecked():
            sel_cdb_schemas = None # For the SQL functions, this is like ALL

        else:
            # Get the selected cdb_schemas
            sel_cdb_schemas: list = gen_f.get_checkedItemsData(self.ccbSelCDBSch)
            # print ("Selected cdb_schemas:", sel_cdb_schemas)

            # Check that at least a cdb_schema has been selected
            if len(sel_cdb_schemas) == 0:
                msg = f"You must select at least one citydb schema!"
                QMessageBox.warning(self, "Invalid selection", msg)
                return None # Exit and do nothing

        selected_priv = self.cbxSelPriv.currentText()
        # print ("Selected priv:", selected_priv)

        if selected_priv == "Revoke ALL privileges":
            sql.exec_revoke_qgis_usr_privileges(cdbMain, sel_usr_name, sel_cdb_schemas)
            if not sel_cdb_schemas:
                msg = f"For user '{sel_usr_name}', privileges revoked from ALL citydb schemas."            
            else: 
                msg = f"For user '{sel_usr_name}', privileges revoked from citydb schemas: {sel_cdb_schemas}"  

        elif selected_priv == "Grant Read-only":
            sql.exec_grant_qgis_usr_privileges(cdbMain, sel_usr_name, "ro", sel_cdb_schemas)
            if not sel_cdb_schemas:
                msg = f"For user '{sel_usr_name}', read-only privileges granted to ALL citydb schemas."            
            else: 
                msg = f"For user '{sel_usr_name}', read-only privileges granted to citydb schemas: {sel_cdb_schemas}"  

        elif selected_priv == "Grant Read & Write":
            sql.exec_grant_qgis_usr_privileges(cdbMain, sel_usr_name, "rw", sel_cdb_schemas)
            if not sel_cdb_schemas:
                msg = f"For user '{sel_usr_name}', read & write privileges granted to ALL citydb schemas."            
            else: 
                msg = f"For user '{sel_usr_name}', read & write privileges granted to citydb schemas: {sel_cdb_schemas}"  

        # Retrieve again the list of cdb_schemas and their privileges status
        # Function returns a list of named tuples (cdb_schema, co_number, priv_type)
        cdb_schemas = sql.exec_list_cdb_schemas_extended(cdbMain, sel_usr_name)
        # Fill the combobox of the cdb_schemas in the groupbox
        ti_wf.fill_cdb_schemas_box(cdbMain, cdb_schemas)

        # Inform the user
        QMessageBox.information(self, "Setting privileges", msg)
        QgsMessageLog.logMessage(msg, cdbMain.PLUGIN_NAME, level=Qgis.Info)

        return None


    def evt_btnCloseConn_clicked(self, cdbMain: CDBToolsMain) -> None:
        """Event that is called when the 'Close current connection' pushButton
        (btnCloseConn) is pressed.
        """
        ts_wf.tabSettings_reset(cdbMain)
        ti_wf.tabInstall_reset(cdbMain)
        # Close the current open connection.
        if cdbMain.conn is not None:
            cdbMain.conn.close()

    ####  Events for 'Settings' TAB

    def evt_ckbUserRO_toggled(self) -> None:
        """Toggles the status of the checkbox to install the default RO user on off.
        If off, it also disables the child checkbox regarding schema installation and privileges.
        """
        status: bool = self.ckbUserRO.isChecked()
        if status:
            self.ckbUserROAccess.setDisabled(False)
        else:
            self.ckbUserROAccess.setChecked(False)
            self.ckbUserROAccess.setDisabled(True)

        return None


    def evt_ckbUserRW_toggled(self) -> None:
        """Toggles the status of the checkbox to install the default RW user on off.
        If off, it also disables the child checkbox regarding schema installation and privileges.
        """
        status: bool = self.ckbUserRW.isChecked()
        if status:
            self.ckbUserRWAccess.setDisabled(False)
        else:
            self.ckbUserRWAccess.setChecked(False)
            self.ckbUserRWAccess.setDisabled(True)

        return None


    def evt_btnResetToDefault_clicked(self, cdbMain: CDBToolsMain) -> None:
        """Event that is called when the button 'Reset to default values' is clicked
        """
        # Reset and enables the Default Users groupbox
        ts_wf.gbxDefaultUsers_reset(cdbMain) # also disables
        self.gbxDefaultUsers.setDisabled(False)

        return None

    #-EVENT FUNCTIONS (end) #####################################################################